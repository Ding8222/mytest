// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef PROTOBUF_Login_2eproto__INCLUDED
#define PROTOBUF_Login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Login_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHandShakeImpl();
void InitDefaultsHandShake();
void InitDefaultsHandShakeRetImpl();
void InitDefaultsHandShakeRet();
void InitDefaultsChallengeImpl();
void InitDefaultsChallenge();
void InitDefaultsChallengeRetImpl();
void InitDefaultsChallengeRet();
void InitDefaultsAuthImpl();
void InitDefaultsAuth();
void InitDefaultsAuthRetImpl();
void InitDefaultsAuthRet();
void InitDefaultsLoginImpl();
void InitDefaultsLogin();
inline void InitDefaults() {
  InitDefaultsHandShake();
  InitDefaultsHandShakeRet();
  InitDefaultsChallenge();
  InitDefaultsChallengeRet();
  InitDefaultsAuth();
  InitDefaultsAuthRet();
  InitDefaultsLogin();
}
}  // namespace protobuf_Login_2eproto
namespace netData {
class Auth;
class AuthDefaultTypeInternal;
extern AuthDefaultTypeInternal _Auth_default_instance_;
class AuthRet;
class AuthRetDefaultTypeInternal;
extern AuthRetDefaultTypeInternal _AuthRet_default_instance_;
class Challenge;
class ChallengeDefaultTypeInternal;
extern ChallengeDefaultTypeInternal _Challenge_default_instance_;
class ChallengeRet;
class ChallengeRetDefaultTypeInternal;
extern ChallengeRetDefaultTypeInternal _ChallengeRet_default_instance_;
class HandShake;
class HandShakeDefaultTypeInternal;
extern HandShakeDefaultTypeInternal _HandShake_default_instance_;
class HandShakeRet;
class HandShakeRetDefaultTypeInternal;
extern HandShakeRetDefaultTypeInternal _HandShakeRet_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
}  // namespace netData
namespace netData {

enum ChallengeRet_EC {
  ChallengeRet_EC_EC_OTHER = 0,
  ChallengeRet_EC_EC_SUCC = 1,
  ChallengeRet_EC_EC_FAIL = 2,
  ChallengeRet_EC_ChallengeRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChallengeRet_EC_ChallengeRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChallengeRet_EC_IsValid(int value);
const ChallengeRet_EC ChallengeRet_EC_EC_MIN = ChallengeRet_EC_EC_OTHER;
const ChallengeRet_EC ChallengeRet_EC_EC_MAX = ChallengeRet_EC_EC_FAIL;
const int ChallengeRet_EC_EC_ARRAYSIZE = ChallengeRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChallengeRet_EC_descriptor();
inline const ::std::string& ChallengeRet_EC_Name(ChallengeRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChallengeRet_EC_descriptor(), value);
}
inline bool ChallengeRet_EC_Parse(
    const ::std::string& name, ChallengeRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChallengeRet_EC>(
    ChallengeRet_EC_descriptor(), name, value);
}
enum AuthRet_EC {
  AuthRet_EC_EC_OTHER = 0,
  AuthRet_EC_EC_SUCC = 1,
  AuthRet_EC_EC_FAIL = 2,
  AuthRet_EC_EC_HANDSHAKE = 3,
  AuthRet_EC_AuthRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AuthRet_EC_AuthRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AuthRet_EC_IsValid(int value);
const AuthRet_EC AuthRet_EC_EC_MIN = AuthRet_EC_EC_OTHER;
const AuthRet_EC AuthRet_EC_EC_MAX = AuthRet_EC_EC_HANDSHAKE;
const int AuthRet_EC_EC_ARRAYSIZE = AuthRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthRet_EC_descriptor();
inline const ::std::string& AuthRet_EC_Name(AuthRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthRet_EC_descriptor(), value);
}
inline bool AuthRet_EC_Parse(
    const ::std::string& name, AuthRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthRet_EC>(
    AuthRet_EC_descriptor(), name, value);
}
// ===================================================================

class HandShake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.HandShake) */ {
 public:
  HandShake();
  virtual ~HandShake();

  HandShake(const HandShake& from);

  inline HandShake& operator=(const HandShake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandShake(HandShake&& from) noexcept
    : HandShake() {
    *this = ::std::move(from);
  }

  inline HandShake& operator=(HandShake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandShake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandShake* internal_default_instance() {
    return reinterpret_cast<const HandShake*>(
               &_HandShake_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HandShake* other);
  friend void swap(HandShake& a, HandShake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandShake* New() const PROTOBUF_FINAL { return New(NULL); }

  HandShake* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HandShake& from);
  void MergeFrom(const HandShake& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HandShake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes sClientKey = 1;
  void clear_sclientkey();
  static const int kSClientKeyFieldNumber = 1;
  const ::std::string& sclientkey() const;
  void set_sclientkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sclientkey(::std::string&& value);
  #endif
  void set_sclientkey(const char* value);
  void set_sclientkey(const void* value, size_t size);
  ::std::string* mutable_sclientkey();
  ::std::string* release_sclientkey();
  void set_allocated_sclientkey(::std::string* sclientkey);

  // @@protoc_insertion_point(class_scope:netData.HandShake)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sclientkey_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsHandShakeImpl();
};
// -------------------------------------------------------------------

class HandShakeRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.HandShakeRet) */ {
 public:
  HandShakeRet();
  virtual ~HandShakeRet();

  HandShakeRet(const HandShakeRet& from);

  inline HandShakeRet& operator=(const HandShakeRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandShakeRet(HandShakeRet&& from) noexcept
    : HandShakeRet() {
    *this = ::std::move(from);
  }

  inline HandShakeRet& operator=(HandShakeRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandShakeRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandShakeRet* internal_default_instance() {
    return reinterpret_cast<const HandShakeRet*>(
               &_HandShakeRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HandShakeRet* other);
  friend void swap(HandShakeRet& a, HandShakeRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandShakeRet* New() const PROTOBUF_FINAL { return New(NULL); }

  HandShakeRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HandShakeRet& from);
  void MergeFrom(const HandShakeRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HandShakeRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes sChallenge = 1;
  void clear_schallenge();
  static const int kSChallengeFieldNumber = 1;
  const ::std::string& schallenge() const;
  void set_schallenge(const ::std::string& value);
  #if LANG_CXX11
  void set_schallenge(::std::string&& value);
  #endif
  void set_schallenge(const char* value);
  void set_schallenge(const void* value, size_t size);
  ::std::string* mutable_schallenge();
  ::std::string* release_schallenge();
  void set_allocated_schallenge(::std::string* schallenge);

  // bytes sServerKey = 2;
  void clear_sserverkey();
  static const int kSServerKeyFieldNumber = 2;
  const ::std::string& sserverkey() const;
  void set_sserverkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sserverkey(::std::string&& value);
  #endif
  void set_sserverkey(const char* value);
  void set_sserverkey(const void* value, size_t size);
  ::std::string* mutable_sserverkey();
  ::std::string* release_sserverkey();
  void set_allocated_sserverkey(::std::string* sserverkey);

  // @@protoc_insertion_point(class_scope:netData.HandShakeRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr schallenge_;
  ::google::protobuf::internal::ArenaStringPtr sserverkey_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsHandShakeRetImpl();
};
// -------------------------------------------------------------------

class Challenge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Challenge) */ {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Challenge(Challenge&& from) noexcept
    : Challenge() {
    *this = ::std::move(from);
  }

  inline Challenge& operator=(Challenge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Challenge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Challenge* internal_default_instance() {
    return reinterpret_cast<const Challenge*>(
               &_Challenge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Challenge* other);
  friend void swap(Challenge& a, Challenge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Challenge* New() const PROTOBUF_FINAL { return New(NULL); }

  Challenge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Challenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sHmac = 1;
  void clear_shmac();
  static const int kSHmacFieldNumber = 1;
  const ::std::string& shmac() const;
  void set_shmac(const ::std::string& value);
  #if LANG_CXX11
  void set_shmac(::std::string&& value);
  #endif
  void set_shmac(const char* value);
  void set_shmac(const char* value, size_t size);
  ::std::string* mutable_shmac();
  ::std::string* release_shmac();
  void set_allocated_shmac(::std::string* shmac);

  // @@protoc_insertion_point(class_scope:netData.Challenge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr shmac_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsChallengeImpl();
};
// -------------------------------------------------------------------

class ChallengeRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.ChallengeRet) */ {
 public:
  ChallengeRet();
  virtual ~ChallengeRet();

  ChallengeRet(const ChallengeRet& from);

  inline ChallengeRet& operator=(const ChallengeRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChallengeRet(ChallengeRet&& from) noexcept
    : ChallengeRet() {
    *this = ::std::move(from);
  }

  inline ChallengeRet& operator=(ChallengeRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChallengeRet* internal_default_instance() {
    return reinterpret_cast<const ChallengeRet*>(
               &_ChallengeRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ChallengeRet* other);
  friend void swap(ChallengeRet& a, ChallengeRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChallengeRet* New() const PROTOBUF_FINAL { return New(NULL); }

  ChallengeRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChallengeRet& from);
  void MergeFrom(const ChallengeRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChallengeRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChallengeRet_EC EC;
  static const EC EC_OTHER =
    ChallengeRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    ChallengeRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    ChallengeRet_EC_EC_FAIL;
  static inline bool EC_IsValid(int value) {
    return ChallengeRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    ChallengeRet_EC_EC_MIN;
  static const EC EC_MAX =
    ChallengeRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    ChallengeRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return ChallengeRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return ChallengeRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return ChallengeRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.ChallengeRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsChallengeRetImpl();
};
// -------------------------------------------------------------------

class Auth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Auth) */ {
 public:
  Auth();
  virtual ~Auth();

  Auth(const Auth& from);

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Auth(Auth&& from) noexcept
    : Auth() {
    *this = ::std::move(from);
  }

  inline Auth& operator=(Auth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Auth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Auth* internal_default_instance() {
    return reinterpret_cast<const Auth*>(
               &_Auth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Auth* other);
  friend void swap(Auth& a, Auth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Auth* New() const PROTOBUF_FINAL { return New(NULL); }

  Auth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Auth& from);
  void MergeFrom(const Auth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Auth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sEtoken = 1;
  void clear_setoken();
  static const int kSEtokenFieldNumber = 1;
  const ::std::string& setoken() const;
  void set_setoken(const ::std::string& value);
  #if LANG_CXX11
  void set_setoken(::std::string&& value);
  #endif
  void set_setoken(const char* value);
  void set_setoken(const char* value, size_t size);
  ::std::string* mutable_setoken();
  ::std::string* release_setoken();
  void set_allocated_setoken(::std::string* setoken);

  // string sSecret = 2;
  void clear_ssecret();
  static const int kSSecretFieldNumber = 2;
  const ::std::string& ssecret() const;
  void set_ssecret(const ::std::string& value);
  #if LANG_CXX11
  void set_ssecret(::std::string&& value);
  #endif
  void set_ssecret(const char* value);
  void set_ssecret(const char* value, size_t size);
  ::std::string* mutable_ssecret();
  ::std::string* release_ssecret();
  void set_allocated_ssecret(::std::string* ssecret);

  // @@protoc_insertion_point(class_scope:netData.Auth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr setoken_;
  ::google::protobuf::internal::ArenaStringPtr ssecret_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsAuthImpl();
};
// -------------------------------------------------------------------

class AuthRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.AuthRet) */ {
 public:
  AuthRet();
  virtual ~AuthRet();

  AuthRet(const AuthRet& from);

  inline AuthRet& operator=(const AuthRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthRet(AuthRet&& from) noexcept
    : AuthRet() {
    *this = ::std::move(from);
  }

  inline AuthRet& operator=(AuthRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthRet* internal_default_instance() {
    return reinterpret_cast<const AuthRet*>(
               &_AuthRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AuthRet* other);
  friend void swap(AuthRet& a, AuthRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthRet* New() const PROTOBUF_FINAL { return New(NULL); }

  AuthRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthRet& from);
  void MergeFrom(const AuthRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AuthRet_EC EC;
  static const EC EC_OTHER =
    AuthRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    AuthRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    AuthRet_EC_EC_FAIL;
  static const EC EC_HANDSHAKE =
    AuthRet_EC_EC_HANDSHAKE;
  static inline bool EC_IsValid(int value) {
    return AuthRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    AuthRet_EC_EC_MIN;
  static const EC EC_MAX =
    AuthRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    AuthRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return AuthRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return AuthRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return AuthRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string ip = 3;
  void clear_ip();
  static const int kIpFieldNumber = 3;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // int32 nServerID = 2;
  void clear_nserverid();
  static const int kNServerIDFieldNumber = 2;
  ::google::protobuf::int32 nserverid() const;
  void set_nserverid(::google::protobuf::int32 value);

  // int32 port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.AuthRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 ncode_;
  ::google::protobuf::int32 nserverid_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsAuthRetImpl();
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const PROTOBUF_FINAL { return New(NULL); }

  Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sToken = 1;
  void clear_stoken();
  static const int kSTokenFieldNumber = 1;
  const ::std::string& stoken() const;
  void set_stoken(const ::std::string& value);
  #if LANG_CXX11
  void set_stoken(::std::string&& value);
  #endif
  void set_stoken(const char* value);
  void set_stoken(const char* value, size_t size);
  ::std::string* mutable_stoken();
  ::std::string* release_stoken();
  void set_allocated_stoken(::std::string* stoken);

  // @@protoc_insertion_point(class_scope:netData.Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr stoken_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsLoginImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HandShake

// bytes sClientKey = 1;
inline void HandShake::clear_sclientkey() {
  sclientkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShake::sclientkey() const {
  // @@protoc_insertion_point(field_get:netData.HandShake.sClientKey)
  return sclientkey_.GetNoArena();
}
inline void HandShake::set_sclientkey(const ::std::string& value) {
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShake.sClientKey)
}
#if LANG_CXX11
inline void HandShake::set_sclientkey(::std::string&& value) {
  
  sclientkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShake.sClientKey)
}
#endif
inline void HandShake::set_sclientkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShake.sClientKey)
}
inline void HandShake::set_sclientkey(const void* value, size_t size) {
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShake.sClientKey)
}
inline ::std::string* HandShake::mutable_sclientkey() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShake.sClientKey)
  return sclientkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShake::release_sclientkey() {
  // @@protoc_insertion_point(field_release:netData.HandShake.sClientKey)
  
  return sclientkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShake::set_allocated_sclientkey(::std::string* sclientkey) {
  if (sclientkey != NULL) {
    
  } else {
    
  }
  sclientkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sclientkey);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShake.sClientKey)
}

// -------------------------------------------------------------------

// HandShakeRet

// bytes sChallenge = 1;
inline void HandShakeRet::clear_schallenge() {
  schallenge_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShakeRet::schallenge() const {
  // @@protoc_insertion_point(field_get:netData.HandShakeRet.sChallenge)
  return schallenge_.GetNoArena();
}
inline void HandShakeRet::set_schallenge(const ::std::string& value) {
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShakeRet.sChallenge)
}
#if LANG_CXX11
inline void HandShakeRet::set_schallenge(::std::string&& value) {
  
  schallenge_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShakeRet.sChallenge)
}
#endif
inline void HandShakeRet::set_schallenge(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShakeRet.sChallenge)
}
inline void HandShakeRet::set_schallenge(const void* value, size_t size) {
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShakeRet.sChallenge)
}
inline ::std::string* HandShakeRet::mutable_schallenge() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShakeRet.sChallenge)
  return schallenge_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShakeRet::release_schallenge() {
  // @@protoc_insertion_point(field_release:netData.HandShakeRet.sChallenge)
  
  return schallenge_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShakeRet::set_allocated_schallenge(::std::string* schallenge) {
  if (schallenge != NULL) {
    
  } else {
    
  }
  schallenge_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schallenge);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShakeRet.sChallenge)
}

// bytes sServerKey = 2;
inline void HandShakeRet::clear_sserverkey() {
  sserverkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShakeRet::sserverkey() const {
  // @@protoc_insertion_point(field_get:netData.HandShakeRet.sServerKey)
  return sserverkey_.GetNoArena();
}
inline void HandShakeRet::set_sserverkey(const ::std::string& value) {
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShakeRet.sServerKey)
}
#if LANG_CXX11
inline void HandShakeRet::set_sserverkey(::std::string&& value) {
  
  sserverkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShakeRet.sServerKey)
}
#endif
inline void HandShakeRet::set_sserverkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShakeRet.sServerKey)
}
inline void HandShakeRet::set_sserverkey(const void* value, size_t size) {
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShakeRet.sServerKey)
}
inline ::std::string* HandShakeRet::mutable_sserverkey() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShakeRet.sServerKey)
  return sserverkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShakeRet::release_sserverkey() {
  // @@protoc_insertion_point(field_release:netData.HandShakeRet.sServerKey)
  
  return sserverkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShakeRet::set_allocated_sserverkey(::std::string* sserverkey) {
  if (sserverkey != NULL) {
    
  } else {
    
  }
  sserverkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sserverkey);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShakeRet.sServerKey)
}

// -------------------------------------------------------------------

// Challenge

// string sHmac = 1;
inline void Challenge::clear_shmac() {
  shmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Challenge::shmac() const {
  // @@protoc_insertion_point(field_get:netData.Challenge.sHmac)
  return shmac_.GetNoArena();
}
inline void Challenge::set_shmac(const ::std::string& value) {
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Challenge.sHmac)
}
#if LANG_CXX11
inline void Challenge::set_shmac(::std::string&& value) {
  
  shmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Challenge.sHmac)
}
#endif
inline void Challenge::set_shmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Challenge.sHmac)
}
inline void Challenge::set_shmac(const char* value, size_t size) {
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Challenge.sHmac)
}
inline ::std::string* Challenge::mutable_shmac() {
  
  // @@protoc_insertion_point(field_mutable:netData.Challenge.sHmac)
  return shmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Challenge::release_shmac() {
  // @@protoc_insertion_point(field_release:netData.Challenge.sHmac)
  
  return shmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Challenge::set_allocated_shmac(::std::string* shmac) {
  if (shmac != NULL) {
    
  } else {
    
  }
  shmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shmac);
  // @@protoc_insertion_point(field_set_allocated:netData.Challenge.sHmac)
}

// -------------------------------------------------------------------

// ChallengeRet

// int32 nCode = 1;
inline void ChallengeRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 ChallengeRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.ChallengeRet.nCode)
  return ncode_;
}
inline void ChallengeRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.ChallengeRet.nCode)
}

// -------------------------------------------------------------------

// Auth

// string sEtoken = 1;
inline void Auth::clear_setoken() {
  setoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::setoken() const {
  // @@protoc_insertion_point(field_get:netData.Auth.sEtoken)
  return setoken_.GetNoArena();
}
inline void Auth::set_setoken(const ::std::string& value) {
  
  setoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Auth.sEtoken)
}
#if LANG_CXX11
inline void Auth::set_setoken(::std::string&& value) {
  
  setoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Auth.sEtoken)
}
#endif
inline void Auth::set_setoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  setoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Auth.sEtoken)
}
inline void Auth::set_setoken(const char* value, size_t size) {
  
  setoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Auth.sEtoken)
}
inline ::std::string* Auth::mutable_setoken() {
  
  // @@protoc_insertion_point(field_mutable:netData.Auth.sEtoken)
  return setoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_setoken() {
  // @@protoc_insertion_point(field_release:netData.Auth.sEtoken)
  
  return setoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_setoken(::std::string* setoken) {
  if (setoken != NULL) {
    
  } else {
    
  }
  setoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), setoken);
  // @@protoc_insertion_point(field_set_allocated:netData.Auth.sEtoken)
}

// string sSecret = 2;
inline void Auth::clear_ssecret() {
  ssecret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::ssecret() const {
  // @@protoc_insertion_point(field_get:netData.Auth.sSecret)
  return ssecret_.GetNoArena();
}
inline void Auth::set_ssecret(const ::std::string& value) {
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Auth.sSecret)
}
#if LANG_CXX11
inline void Auth::set_ssecret(::std::string&& value) {
  
  ssecret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Auth.sSecret)
}
#endif
inline void Auth::set_ssecret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Auth.sSecret)
}
inline void Auth::set_ssecret(const char* value, size_t size) {
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Auth.sSecret)
}
inline ::std::string* Auth::mutable_ssecret() {
  
  // @@protoc_insertion_point(field_mutable:netData.Auth.sSecret)
  return ssecret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_ssecret() {
  // @@protoc_insertion_point(field_release:netData.Auth.sSecret)
  
  return ssecret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_ssecret(::std::string* ssecret) {
  if (ssecret != NULL) {
    
  } else {
    
  }
  ssecret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssecret);
  // @@protoc_insertion_point(field_set_allocated:netData.Auth.sSecret)
}

// -------------------------------------------------------------------

// AuthRet

// int32 nCode = 1;
inline void AuthRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 AuthRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.nCode)
  return ncode_;
}
inline void AuthRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.AuthRet.nCode)
}

// int32 nServerID = 2;
inline void AuthRet::clear_nserverid() {
  nserverid_ = 0;
}
inline ::google::protobuf::int32 AuthRet::nserverid() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.nServerID)
  return nserverid_;
}
inline void AuthRet::set_nserverid(::google::protobuf::int32 value) {
  
  nserverid_ = value;
  // @@protoc_insertion_point(field_set:netData.AuthRet.nServerID)
}

// string ip = 3;
inline void AuthRet::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthRet::ip() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.ip)
  return ip_.GetNoArena();
}
inline void AuthRet::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.AuthRet.ip)
}
#if LANG_CXX11
inline void AuthRet::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.AuthRet.ip)
}
#endif
inline void AuthRet::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.AuthRet.ip)
}
inline void AuthRet::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.AuthRet.ip)
}
inline ::std::string* AuthRet::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:netData.AuthRet.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthRet::release_ip() {
  // @@protoc_insertion_point(field_release:netData.AuthRet.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthRet::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:netData.AuthRet.ip)
}

// int32 port = 4;
inline void AuthRet::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 AuthRet::port() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.port)
  return port_;
}
inline void AuthRet::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:netData.AuthRet.port)
}

// -------------------------------------------------------------------

// Login

// string sToken = 1;
inline void Login::clear_stoken() {
  stoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::stoken() const {
  // @@protoc_insertion_point(field_get:netData.Login.sToken)
  return stoken_.GetNoArena();
}
inline void Login::set_stoken(const ::std::string& value) {
  
  stoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Login.sToken)
}
#if LANG_CXX11
inline void Login::set_stoken(::std::string&& value) {
  
  stoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Login.sToken)
}
#endif
inline void Login::set_stoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Login.sToken)
}
inline void Login::set_stoken(const char* value, size_t size) {
  
  stoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Login.sToken)
}
inline ::std::string* Login::mutable_stoken() {
  
  // @@protoc_insertion_point(field_mutable:netData.Login.sToken)
  return stoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_stoken() {
  // @@protoc_insertion_point(field_release:netData.Login.sToken)
  
  return stoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_stoken(::std::string* stoken) {
  if (stoken != NULL) {
    
  } else {
    
  }
  stoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stoken);
  // @@protoc_insertion_point(field_set_allocated:netData.Login.sToken)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace netData

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::netData::ChallengeRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::ChallengeRet_EC>() {
  return ::netData::ChallengeRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::AuthRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::AuthRet_EC>() {
  return ::netData::AuthRet_EC_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Login_2eproto__INCLUDED
