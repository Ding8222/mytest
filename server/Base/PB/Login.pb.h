// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef PROTOBUF_Login_2eproto_INCLUDED
#define PROTOBUF_Login_2eproto_INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Login_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHandShakeImpl();
void InitDefaultsHandShake();
void InitDefaultsHandShakeRetImpl();
void InitDefaultsHandShakeRet();
void InitDefaultsChallengeImpl();
void InitDefaultsChallenge();
void InitDefaultsChallengeRetImpl();
void InitDefaultsChallengeRet();
void InitDefaultsAuthImpl();
void InitDefaultsAuth();
void InitDefaultsAuthRetImpl();
void InitDefaultsAuthRet();
void InitDefaultsLoginImpl();
void InitDefaultsLogin();
void InitDefaultsLoginRetImpl();
void InitDefaultsLoginRet();
void InitDefaultsPlayerLiteImpl();
void InitDefaultsPlayerLite();
void InitDefaultsPlayerListImpl();
void InitDefaultsPlayerList();
void InitDefaultsPlayerListRetImpl();
void InitDefaultsPlayerListRet();
void InitDefaultsCreatePlayerImpl();
void InitDefaultsCreatePlayer();
void InitDefaultsCreatePlayerRetImpl();
void InitDefaultsCreatePlayerRet();
void InitDefaultsSelectPlayerImpl();
void InitDefaultsSelectPlayer();
void InitDefaultsSelectPlayerRetImpl();
void InitDefaultsSelectPlayerRet();
inline void InitDefaults() {
  InitDefaultsHandShake();
  InitDefaultsHandShakeRet();
  InitDefaultsChallenge();
  InitDefaultsChallengeRet();
  InitDefaultsAuth();
  InitDefaultsAuthRet();
  InitDefaultsLogin();
  InitDefaultsLoginRet();
  InitDefaultsPlayerLite();
  InitDefaultsPlayerList();
  InitDefaultsPlayerListRet();
  InitDefaultsCreatePlayer();
  InitDefaultsCreatePlayerRet();
  InitDefaultsSelectPlayer();
  InitDefaultsSelectPlayerRet();
}
}  // namespace protobuf_Login_2eproto
namespace netData {
class Auth;
class AuthDefaultTypeInternal;
extern AuthDefaultTypeInternal _Auth_default_instance_;
class AuthRet;
class AuthRetDefaultTypeInternal;
extern AuthRetDefaultTypeInternal _AuthRet_default_instance_;
class Challenge;
class ChallengeDefaultTypeInternal;
extern ChallengeDefaultTypeInternal _Challenge_default_instance_;
class ChallengeRet;
class ChallengeRetDefaultTypeInternal;
extern ChallengeRetDefaultTypeInternal _ChallengeRet_default_instance_;
class CreatePlayer;
class CreatePlayerDefaultTypeInternal;
extern CreatePlayerDefaultTypeInternal _CreatePlayer_default_instance_;
class CreatePlayerRet;
class CreatePlayerRetDefaultTypeInternal;
extern CreatePlayerRetDefaultTypeInternal _CreatePlayerRet_default_instance_;
class HandShake;
class HandShakeDefaultTypeInternal;
extern HandShakeDefaultTypeInternal _HandShake_default_instance_;
class HandShakeRet;
class HandShakeRetDefaultTypeInternal;
extern HandShakeRetDefaultTypeInternal _HandShakeRet_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class LoginRet;
class LoginRetDefaultTypeInternal;
extern LoginRetDefaultTypeInternal _LoginRet_default_instance_;
class PlayerList;
class PlayerListDefaultTypeInternal;
extern PlayerListDefaultTypeInternal _PlayerList_default_instance_;
class PlayerListRet;
class PlayerListRetDefaultTypeInternal;
extern PlayerListRetDefaultTypeInternal _PlayerListRet_default_instance_;
class PlayerLite;
class PlayerLiteDefaultTypeInternal;
extern PlayerLiteDefaultTypeInternal _PlayerLite_default_instance_;
class SelectPlayer;
class SelectPlayerDefaultTypeInternal;
extern SelectPlayerDefaultTypeInternal _SelectPlayer_default_instance_;
class SelectPlayerRet;
class SelectPlayerRetDefaultTypeInternal;
extern SelectPlayerRetDefaultTypeInternal _SelectPlayerRet_default_instance_;
}  // namespace netData
namespace google {
namespace protobuf {
template<> ::netData::Auth* Arena::Create< ::netData::Auth>(Arena*);
template<> ::netData::AuthRet* Arena::Create< ::netData::AuthRet>(Arena*);
template<> ::netData::Challenge* Arena::Create< ::netData::Challenge>(Arena*);
template<> ::netData::ChallengeRet* Arena::Create< ::netData::ChallengeRet>(Arena*);
template<> ::netData::CreatePlayer* Arena::Create< ::netData::CreatePlayer>(Arena*);
template<> ::netData::CreatePlayerRet* Arena::Create< ::netData::CreatePlayerRet>(Arena*);
template<> ::netData::HandShake* Arena::Create< ::netData::HandShake>(Arena*);
template<> ::netData::HandShakeRet* Arena::Create< ::netData::HandShakeRet>(Arena*);
template<> ::netData::Login* Arena::Create< ::netData::Login>(Arena*);
template<> ::netData::LoginRet* Arena::Create< ::netData::LoginRet>(Arena*);
template<> ::netData::PlayerList* Arena::Create< ::netData::PlayerList>(Arena*);
template<> ::netData::PlayerListRet* Arena::Create< ::netData::PlayerListRet>(Arena*);
template<> ::netData::PlayerLite* Arena::Create< ::netData::PlayerLite>(Arena*);
template<> ::netData::SelectPlayer* Arena::Create< ::netData::SelectPlayer>(Arena*);
template<> ::netData::SelectPlayerRet* Arena::Create< ::netData::SelectPlayerRet>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace netData {

enum ChallengeRet_EC {
  ChallengeRet_EC_EC_OTHER = 0,
  ChallengeRet_EC_EC_SUCC = 1,
  ChallengeRet_EC_EC_FAIL = 2,
  ChallengeRet_EC_ChallengeRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChallengeRet_EC_ChallengeRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChallengeRet_EC_IsValid(int value);
const ChallengeRet_EC ChallengeRet_EC_EC_MIN = ChallengeRet_EC_EC_OTHER;
const ChallengeRet_EC ChallengeRet_EC_EC_MAX = ChallengeRet_EC_EC_FAIL;
const int ChallengeRet_EC_EC_ARRAYSIZE = ChallengeRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChallengeRet_EC_descriptor();
inline const ::std::string& ChallengeRet_EC_Name(ChallengeRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChallengeRet_EC_descriptor(), value);
}
inline bool ChallengeRet_EC_Parse(
    const ::std::string& name, ChallengeRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChallengeRet_EC>(
    ChallengeRet_EC_descriptor(), name, value);
}
enum AuthRet_EC {
  AuthRet_EC_EC_OTHER = 0,
  AuthRet_EC_EC_SUCC = 1,
  AuthRet_EC_EC_FAIL = 2,
  AuthRet_EC_EC_HANDSHAKE = 3,
  AuthRet_EC_EC_SERVER = 4,
  AuthRet_EC_EC_DB = 5,
  AuthRet_EC_EC_AUTHINFO = 6,
  AuthRet_EC_AuthRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AuthRet_EC_AuthRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AuthRet_EC_IsValid(int value);
const AuthRet_EC AuthRet_EC_EC_MIN = AuthRet_EC_EC_OTHER;
const AuthRet_EC AuthRet_EC_EC_MAX = AuthRet_EC_EC_AUTHINFO;
const int AuthRet_EC_EC_ARRAYSIZE = AuthRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthRet_EC_descriptor();
inline const ::std::string& AuthRet_EC_Name(AuthRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthRet_EC_descriptor(), value);
}
inline bool AuthRet_EC_Parse(
    const ::std::string& name, AuthRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthRet_EC>(
    AuthRet_EC_descriptor(), name, value);
}
enum LoginRet_EC {
  LoginRet_EC_EC_OTHER = 0,
  LoginRet_EC_EC_SUCC = 1,
  LoginRet_EC_EC_FAIL = 2,
  LoginRet_EC_LoginRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoginRet_EC_LoginRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoginRet_EC_IsValid(int value);
const LoginRet_EC LoginRet_EC_EC_MIN = LoginRet_EC_EC_OTHER;
const LoginRet_EC LoginRet_EC_EC_MAX = LoginRet_EC_EC_FAIL;
const int LoginRet_EC_EC_ARRAYSIZE = LoginRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginRet_EC_descriptor();
inline const ::std::string& LoginRet_EC_Name(LoginRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginRet_EC_descriptor(), value);
}
inline bool LoginRet_EC_Parse(
    const ::std::string& name, LoginRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginRet_EC>(
    LoginRet_EC_descriptor(), name, value);
}
enum CreatePlayerRet_EC {
  CreatePlayerRet_EC_EC_OTHER = 0,
  CreatePlayerRet_EC_EC_SUCC = 1,
  CreatePlayerRet_EC_EC_FAIL = 2,
  CreatePlayerRet_EC_CreatePlayerRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CreatePlayerRet_EC_CreatePlayerRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CreatePlayerRet_EC_IsValid(int value);
const CreatePlayerRet_EC CreatePlayerRet_EC_EC_MIN = CreatePlayerRet_EC_EC_OTHER;
const CreatePlayerRet_EC CreatePlayerRet_EC_EC_MAX = CreatePlayerRet_EC_EC_FAIL;
const int CreatePlayerRet_EC_EC_ARRAYSIZE = CreatePlayerRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreatePlayerRet_EC_descriptor();
inline const ::std::string& CreatePlayerRet_EC_Name(CreatePlayerRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreatePlayerRet_EC_descriptor(), value);
}
inline bool CreatePlayerRet_EC_Parse(
    const ::std::string& name, CreatePlayerRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreatePlayerRet_EC>(
    CreatePlayerRet_EC_descriptor(), name, value);
}
enum SelectPlayerRet_EC {
  SelectPlayerRet_EC_EC_OTHER = 0,
  SelectPlayerRet_EC_EC_SUCC = 1,
  SelectPlayerRet_EC_EC_FAIL = 2,
  SelectPlayerRet_EC_SelectPlayerRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SelectPlayerRet_EC_SelectPlayerRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SelectPlayerRet_EC_IsValid(int value);
const SelectPlayerRet_EC SelectPlayerRet_EC_EC_MIN = SelectPlayerRet_EC_EC_OTHER;
const SelectPlayerRet_EC SelectPlayerRet_EC_EC_MAX = SelectPlayerRet_EC_EC_FAIL;
const int SelectPlayerRet_EC_EC_ARRAYSIZE = SelectPlayerRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectPlayerRet_EC_descriptor();
inline const ::std::string& SelectPlayerRet_EC_Name(SelectPlayerRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectPlayerRet_EC_descriptor(), value);
}
inline bool SelectPlayerRet_EC_Parse(
    const ::std::string& name, SelectPlayerRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectPlayerRet_EC>(
    SelectPlayerRet_EC_descriptor(), name, value);
}
// ===================================================================

class HandShake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.HandShake) */ {
 public:
  HandShake();
  virtual ~HandShake();

  HandShake(const HandShake& from);

  inline HandShake& operator=(const HandShake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandShake(HandShake&& from) noexcept
    : HandShake() {
    *this = ::std::move(from);
  }

  inline HandShake& operator=(HandShake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandShake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandShake* internal_default_instance() {
    return reinterpret_cast<const HandShake*>(
               &_HandShake_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HandShake* other);
  friend void swap(HandShake& a, HandShake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandShake* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShake>(NULL);
  }

  HandShake* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HandShake& from);
  void MergeFrom(const HandShake& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HandShake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes sClientKey = 1;
  void clear_sclientkey();
  static const int kSClientKeyFieldNumber = 1;
  const ::std::string& sclientkey() const;
  void set_sclientkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sclientkey(::std::string&& value);
  #endif
  void set_sclientkey(const char* value);
  void set_sclientkey(const void* value, size_t size);
  ::std::string* mutable_sclientkey();
  ::std::string* release_sclientkey();
  void set_allocated_sclientkey(::std::string* sclientkey);

  // @@protoc_insertion_point(class_scope:netData.HandShake)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sclientkey_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsHandShakeImpl();
};
// -------------------------------------------------------------------

class HandShakeRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.HandShakeRet) */ {
 public:
  HandShakeRet();
  virtual ~HandShakeRet();

  HandShakeRet(const HandShakeRet& from);

  inline HandShakeRet& operator=(const HandShakeRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandShakeRet(HandShakeRet&& from) noexcept
    : HandShakeRet() {
    *this = ::std::move(from);
  }

  inline HandShakeRet& operator=(HandShakeRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandShakeRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandShakeRet* internal_default_instance() {
    return reinterpret_cast<const HandShakeRet*>(
               &_HandShakeRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HandShakeRet* other);
  friend void swap(HandShakeRet& a, HandShakeRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandShakeRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShakeRet>(NULL);
  }

  HandShakeRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShakeRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HandShakeRet& from);
  void MergeFrom(const HandShakeRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HandShakeRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes sChallenge = 1;
  void clear_schallenge();
  static const int kSChallengeFieldNumber = 1;
  const ::std::string& schallenge() const;
  void set_schallenge(const ::std::string& value);
  #if LANG_CXX11
  void set_schallenge(::std::string&& value);
  #endif
  void set_schallenge(const char* value);
  void set_schallenge(const void* value, size_t size);
  ::std::string* mutable_schallenge();
  ::std::string* release_schallenge();
  void set_allocated_schallenge(::std::string* schallenge);

  // bytes sServerKey = 2;
  void clear_sserverkey();
  static const int kSServerKeyFieldNumber = 2;
  const ::std::string& sserverkey() const;
  void set_sserverkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sserverkey(::std::string&& value);
  #endif
  void set_sserverkey(const char* value);
  void set_sserverkey(const void* value, size_t size);
  ::std::string* mutable_sserverkey();
  ::std::string* release_sserverkey();
  void set_allocated_sserverkey(::std::string* sserverkey);

  // @@protoc_insertion_point(class_scope:netData.HandShakeRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr schallenge_;
  ::google::protobuf::internal::ArenaStringPtr sserverkey_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsHandShakeRetImpl();
};
// -------------------------------------------------------------------

class Challenge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Challenge) */ {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Challenge(Challenge&& from) noexcept
    : Challenge() {
    *this = ::std::move(from);
  }

  inline Challenge& operator=(Challenge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Challenge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Challenge* internal_default_instance() {
    return reinterpret_cast<const Challenge*>(
               &_Challenge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Challenge* other);
  friend void swap(Challenge& a, Challenge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Challenge* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Challenge>(NULL);
  }

  Challenge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Challenge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Challenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sHmac = 1;
  void clear_shmac();
  static const int kSHmacFieldNumber = 1;
  const ::std::string& shmac() const;
  void set_shmac(const ::std::string& value);
  #if LANG_CXX11
  void set_shmac(::std::string&& value);
  #endif
  void set_shmac(const char* value);
  void set_shmac(const char* value, size_t size);
  ::std::string* mutable_shmac();
  ::std::string* release_shmac();
  void set_allocated_shmac(::std::string* shmac);

  // @@protoc_insertion_point(class_scope:netData.Challenge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr shmac_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsChallengeImpl();
};
// -------------------------------------------------------------------

class ChallengeRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.ChallengeRet) */ {
 public:
  ChallengeRet();
  virtual ~ChallengeRet();

  ChallengeRet(const ChallengeRet& from);

  inline ChallengeRet& operator=(const ChallengeRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChallengeRet(ChallengeRet&& from) noexcept
    : ChallengeRet() {
    *this = ::std::move(from);
  }

  inline ChallengeRet& operator=(ChallengeRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChallengeRet* internal_default_instance() {
    return reinterpret_cast<const ChallengeRet*>(
               &_ChallengeRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ChallengeRet* other);
  friend void swap(ChallengeRet& a, ChallengeRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChallengeRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ChallengeRet>(NULL);
  }

  ChallengeRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ChallengeRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChallengeRet& from);
  void MergeFrom(const ChallengeRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChallengeRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChallengeRet_EC EC;
  static const EC EC_OTHER =
    ChallengeRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    ChallengeRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    ChallengeRet_EC_EC_FAIL;
  static inline bool EC_IsValid(int value) {
    return ChallengeRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    ChallengeRet_EC_EC_MIN;
  static const EC EC_MAX =
    ChallengeRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    ChallengeRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return ChallengeRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return ChallengeRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return ChallengeRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.ChallengeRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsChallengeRetImpl();
};
// -------------------------------------------------------------------

class Auth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Auth) */ {
 public:
  Auth();
  virtual ~Auth();

  Auth(const Auth& from);

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Auth(Auth&& from) noexcept
    : Auth() {
    *this = ::std::move(from);
  }

  inline Auth& operator=(Auth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Auth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Auth* internal_default_instance() {
    return reinterpret_cast<const Auth*>(
               &_Auth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Auth* other);
  friend void swap(Auth& a, Auth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Auth* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Auth>(NULL);
  }

  Auth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Auth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Auth& from);
  void MergeFrom(const Auth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Auth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sEtoken = 1;
  void clear_setoken();
  static const int kSEtokenFieldNumber = 1;
  const ::std::string& setoken() const;
  void set_setoken(const ::std::string& value);
  #if LANG_CXX11
  void set_setoken(::std::string&& value);
  #endif
  void set_setoken(const char* value);
  void set_setoken(const char* value, size_t size);
  ::std::string* mutable_setoken();
  ::std::string* release_setoken();
  void set_allocated_setoken(::std::string* setoken);

  // bytes sSecret = 2;
  void clear_ssecret();
  static const int kSSecretFieldNumber = 2;
  const ::std::string& ssecret() const;
  void set_ssecret(const ::std::string& value);
  #if LANG_CXX11
  void set_ssecret(::std::string&& value);
  #endif
  void set_ssecret(const char* value);
  void set_ssecret(const void* value, size_t size);
  ::std::string* mutable_ssecret();
  ::std::string* release_ssecret();
  void set_allocated_ssecret(::std::string* ssecret);

  // @@protoc_insertion_point(class_scope:netData.Auth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr setoken_;
  ::google::protobuf::internal::ArenaStringPtr ssecret_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsAuthImpl();
};
// -------------------------------------------------------------------

class AuthRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.AuthRet) */ {
 public:
  AuthRet();
  virtual ~AuthRet();

  AuthRet(const AuthRet& from);

  inline AuthRet& operator=(const AuthRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthRet(AuthRet&& from) noexcept
    : AuthRet() {
    *this = ::std::move(from);
  }

  inline AuthRet& operator=(AuthRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthRet* internal_default_instance() {
    return reinterpret_cast<const AuthRet*>(
               &_AuthRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AuthRet* other);
  friend void swap(AuthRet& a, AuthRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AuthRet>(NULL);
  }

  AuthRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AuthRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthRet& from);
  void MergeFrom(const AuthRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AuthRet_EC EC;
  static const EC EC_OTHER =
    AuthRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    AuthRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    AuthRet_EC_EC_FAIL;
  static const EC EC_HANDSHAKE =
    AuthRet_EC_EC_HANDSHAKE;
  static const EC EC_SERVER =
    AuthRet_EC_EC_SERVER;
  static const EC EC_DB =
    AuthRet_EC_EC_DB;
  static const EC EC_AUTHINFO =
    AuthRet_EC_EC_AUTHINFO;
  static inline bool EC_IsValid(int value) {
    return AuthRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    AuthRet_EC_EC_MIN;
  static const EC EC_MAX =
    AuthRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    AuthRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return AuthRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return AuthRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return AuthRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string ip = 3;
  void clear_ip();
  static const int kIpFieldNumber = 3;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // int32 nServerID = 2;
  void clear_nserverid();
  static const int kNServerIDFieldNumber = 2;
  ::google::protobuf::int32 nserverid() const;
  void set_nserverid(::google::protobuf::int32 value);

  // int32 port = 4;
  void clear_port();
  static const int kPortFieldNumber = 4;
  ::google::protobuf::int32 port() const;
  void set_port(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.AuthRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::int32 ncode_;
  ::google::protobuf::int32 nserverid_;
  ::google::protobuf::int32 port_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsAuthRetImpl();
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Login>(NULL);
  }

  Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Login>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sToken = 1;
  void clear_stoken();
  static const int kSTokenFieldNumber = 1;
  const ::std::string& stoken() const;
  void set_stoken(const ::std::string& value);
  #if LANG_CXX11
  void set_stoken(::std::string&& value);
  #endif
  void set_stoken(const char* value);
  void set_stoken(const char* value, size_t size);
  ::std::string* mutable_stoken();
  ::std::string* release_stoken();
  void set_allocated_stoken(::std::string* stoken);

  // bytes sSecret = 2;
  void clear_ssecret();
  static const int kSSecretFieldNumber = 2;
  const ::std::string& ssecret() const;
  void set_ssecret(const ::std::string& value);
  #if LANG_CXX11
  void set_ssecret(::std::string&& value);
  #endif
  void set_ssecret(const char* value);
  void set_ssecret(const void* value, size_t size);
  ::std::string* mutable_ssecret();
  ::std::string* release_ssecret();
  void set_allocated_ssecret(::std::string* ssecret);

  // @@protoc_insertion_point(class_scope:netData.Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr stoken_;
  ::google::protobuf::internal::ArenaStringPtr ssecret_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsLoginImpl();
};
// -------------------------------------------------------------------

class LoginRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.LoginRet) */ {
 public:
  LoginRet();
  virtual ~LoginRet();

  LoginRet(const LoginRet& from);

  inline LoginRet& operator=(const LoginRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRet(LoginRet&& from) noexcept
    : LoginRet() {
    *this = ::std::move(from);
  }

  inline LoginRet& operator=(LoginRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRet* internal_default_instance() {
    return reinterpret_cast<const LoginRet*>(
               &_LoginRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(LoginRet* other);
  friend void swap(LoginRet& a, LoginRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginRet>(NULL);
  }

  LoginRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRet& from);
  void MergeFrom(const LoginRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LoginRet_EC EC;
  static const EC EC_OTHER =
    LoginRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    LoginRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    LoginRet_EC_EC_FAIL;
  static inline bool EC_IsValid(int value) {
    return LoginRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    LoginRet_EC_EC_MIN;
  static const EC EC_MAX =
    LoginRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    LoginRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return LoginRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return LoginRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return LoginRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.LoginRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsLoginRetImpl();
};
// -------------------------------------------------------------------

class PlayerLite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.PlayerLite) */ {
 public:
  PlayerLite();
  virtual ~PlayerLite();

  PlayerLite(const PlayerLite& from);

  inline PlayerLite& operator=(const PlayerLite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLite(PlayerLite&& from) noexcept
    : PlayerLite() {
    *this = ::std::move(from);
  }

  inline PlayerLite& operator=(PlayerLite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLite* internal_default_instance() {
    return reinterpret_cast<const PlayerLite*>(
               &_PlayerLite_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(PlayerLite* other);
  friend void swap(PlayerLite& a, PlayerLite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLite* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerLite>(NULL);
  }

  PlayerLite* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerLite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLite& from);
  void MergeFrom(const PlayerLite& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sName = 2;
  void clear_sname();
  static const int kSNameFieldNumber = 2;
  const ::std::string& sname() const;
  void set_sname(const ::std::string& value);
  #if LANG_CXX11
  void set_sname(::std::string&& value);
  #endif
  void set_sname(const char* value);
  void set_sname(const char* value, size_t size);
  ::std::string* mutable_sname();
  ::std::string* release_sname();
  void set_allocated_sname(::std::string* sname);

  // int64 guid = 1;
  void clear_guid();
  static const int kGuidFieldNumber = 1;
  ::google::protobuf::int64 guid() const;
  void set_guid(::google::protobuf::int64 value);

  // int32 nJob = 3;
  void clear_njob();
  static const int kNJobFieldNumber = 3;
  ::google::protobuf::int32 njob() const;
  void set_njob(::google::protobuf::int32 value);

  // int32 nSex = 4;
  void clear_nsex();
  static const int kNSexFieldNumber = 4;
  ::google::protobuf::int32 nsex() const;
  void set_nsex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.PlayerLite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sname_;
  ::google::protobuf::int64 guid_;
  ::google::protobuf::int32 njob_;
  ::google::protobuf::int32 nsex_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsPlayerLiteImpl();
};
// -------------------------------------------------------------------

class PlayerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.PlayerList) */ {
 public:
  PlayerList();
  virtual ~PlayerList();

  PlayerList(const PlayerList& from);

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerList(PlayerList&& from) noexcept
    : PlayerList() {
    *this = ::std::move(from);
  }

  inline PlayerList& operator=(PlayerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerList* internal_default_instance() {
    return reinterpret_cast<const PlayerList*>(
               &_PlayerList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PlayerList* other);
  friend void swap(PlayerList& a, PlayerList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerList* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerList>(NULL);
  }

  PlayerList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:netData.PlayerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsPlayerListImpl();
};
// -------------------------------------------------------------------

class PlayerListRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.PlayerListRet) */ {
 public:
  PlayerListRet();
  virtual ~PlayerListRet();

  PlayerListRet(const PlayerListRet& from);

  inline PlayerListRet& operator=(const PlayerListRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerListRet(PlayerListRet&& from) noexcept
    : PlayerListRet() {
    *this = ::std::move(from);
  }

  inline PlayerListRet& operator=(PlayerListRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerListRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerListRet* internal_default_instance() {
    return reinterpret_cast<const PlayerListRet*>(
               &_PlayerListRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PlayerListRet* other);
  friend void swap(PlayerListRet& a, PlayerListRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerListRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerListRet>(NULL);
  }

  PlayerListRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerListRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerListRet& from);
  void MergeFrom(const PlayerListRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerListRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .netData.PlayerLite list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::netData::PlayerLite* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >*
      mutable_list();
  const ::netData::PlayerLite& list(int index) const;
  ::netData::PlayerLite* add_list();
  const ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >&
      list() const;

  // @@protoc_insertion_point(class_scope:netData.PlayerListRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite > list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsPlayerListRetImpl();
};
// -------------------------------------------------------------------

class CreatePlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.CreatePlayer) */ {
 public:
  CreatePlayer();
  virtual ~CreatePlayer();

  CreatePlayer(const CreatePlayer& from);

  inline CreatePlayer& operator=(const CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatePlayer(CreatePlayer&& from) noexcept
    : CreatePlayer() {
    *this = ::std::move(from);
  }

  inline CreatePlayer& operator=(CreatePlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatePlayer* internal_default_instance() {
    return reinterpret_cast<const CreatePlayer*>(
               &_CreatePlayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CreatePlayer* other);
  friend void swap(CreatePlayer& a, CreatePlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatePlayer* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayer>(NULL);
  }

  CreatePlayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreatePlayer& from);
  void MergeFrom(const CreatePlayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreatePlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sName = 1;
  void clear_sname();
  static const int kSNameFieldNumber = 1;
  const ::std::string& sname() const;
  void set_sname(const ::std::string& value);
  #if LANG_CXX11
  void set_sname(::std::string&& value);
  #endif
  void set_sname(const char* value);
  void set_sname(const char* value, size_t size);
  ::std::string* mutable_sname();
  ::std::string* release_sname();
  void set_allocated_sname(::std::string* sname);

  // string account = 4;
  void clear_account();
  static const int kAccountFieldNumber = 4;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // int32 nJob = 2;
  void clear_njob();
  static const int kNJobFieldNumber = 2;
  ::google::protobuf::int32 njob() const;
  void set_njob(::google::protobuf::int32 value);

  // int32 nSex = 3;
  void clear_nsex();
  static const int kNSexFieldNumber = 3;
  ::google::protobuf::int32 nsex() const;
  void set_nsex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.CreatePlayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sname_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::int32 njob_;
  ::google::protobuf::int32 nsex_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsCreatePlayerImpl();
};
// -------------------------------------------------------------------

class CreatePlayerRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.CreatePlayerRet) */ {
 public:
  CreatePlayerRet();
  virtual ~CreatePlayerRet();

  CreatePlayerRet(const CreatePlayerRet& from);

  inline CreatePlayerRet& operator=(const CreatePlayerRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatePlayerRet(CreatePlayerRet&& from) noexcept
    : CreatePlayerRet() {
    *this = ::std::move(from);
  }

  inline CreatePlayerRet& operator=(CreatePlayerRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayerRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatePlayerRet* internal_default_instance() {
    return reinterpret_cast<const CreatePlayerRet*>(
               &_CreatePlayerRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CreatePlayerRet* other);
  friend void swap(CreatePlayerRet& a, CreatePlayerRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatePlayerRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayerRet>(NULL);
  }

  CreatePlayerRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayerRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreatePlayerRet& from);
  void MergeFrom(const CreatePlayerRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreatePlayerRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CreatePlayerRet_EC EC;
  static const EC EC_OTHER =
    CreatePlayerRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    CreatePlayerRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    CreatePlayerRet_EC_EC_FAIL;
  static inline bool EC_IsValid(int value) {
    return CreatePlayerRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    CreatePlayerRet_EC_EC_MIN;
  static const EC EC_MAX =
    CreatePlayerRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    CreatePlayerRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return CreatePlayerRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return CreatePlayerRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return CreatePlayerRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .netData.PlayerLite info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::netData::PlayerLite& info() const;
  ::netData::PlayerLite* release_info();
  ::netData::PlayerLite* mutable_info();
  void set_allocated_info(::netData::PlayerLite* info);

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.CreatePlayerRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::netData::PlayerLite* info_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsCreatePlayerRetImpl();
};
// -------------------------------------------------------------------

class SelectPlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.SelectPlayer) */ {
 public:
  SelectPlayer();
  virtual ~SelectPlayer();

  SelectPlayer(const SelectPlayer& from);

  inline SelectPlayer& operator=(const SelectPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectPlayer(SelectPlayer&& from) noexcept
    : SelectPlayer() {
    *this = ::std::move(from);
  }

  inline SelectPlayer& operator=(SelectPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectPlayer* internal_default_instance() {
    return reinterpret_cast<const SelectPlayer*>(
               &_SelectPlayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(SelectPlayer* other);
  friend void swap(SelectPlayer& a, SelectPlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectPlayer* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayer>(NULL);
  }

  SelectPlayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectPlayer& from);
  void MergeFrom(const SelectPlayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 guid = 1;
  void clear_guid();
  static const int kGuidFieldNumber = 1;
  ::google::protobuf::int64 guid() const;
  void set_guid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:netData.SelectPlayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 guid_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsSelectPlayerImpl();
};
// -------------------------------------------------------------------

class SelectPlayerRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.SelectPlayerRet) */ {
 public:
  SelectPlayerRet();
  virtual ~SelectPlayerRet();

  SelectPlayerRet(const SelectPlayerRet& from);

  inline SelectPlayerRet& operator=(const SelectPlayerRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectPlayerRet(SelectPlayerRet&& from) noexcept
    : SelectPlayerRet() {
    *this = ::std::move(from);
  }

  inline SelectPlayerRet& operator=(SelectPlayerRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectPlayerRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectPlayerRet* internal_default_instance() {
    return reinterpret_cast<const SelectPlayerRet*>(
               &_SelectPlayerRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SelectPlayerRet* other);
  friend void swap(SelectPlayerRet& a, SelectPlayerRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectPlayerRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayerRet>(NULL);
  }

  SelectPlayerRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayerRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectPlayerRet& from);
  void MergeFrom(const SelectPlayerRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectPlayerRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SelectPlayerRet_EC EC;
  static const EC EC_OTHER =
    SelectPlayerRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    SelectPlayerRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    SelectPlayerRet_EC_EC_FAIL;
  static inline bool EC_IsValid(int value) {
    return SelectPlayerRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    SelectPlayerRet_EC_EC_MIN;
  static const EC EC_MAX =
    SelectPlayerRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    SelectPlayerRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return SelectPlayerRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return SelectPlayerRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return SelectPlayerRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.SelectPlayerRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsSelectPlayerRetImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HandShake

// bytes sClientKey = 1;
inline void HandShake::clear_sclientkey() {
  sclientkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShake::sclientkey() const {
  // @@protoc_insertion_point(field_get:netData.HandShake.sClientKey)
  return sclientkey_.GetNoArena();
}
inline void HandShake::set_sclientkey(const ::std::string& value) {
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShake.sClientKey)
}
#if LANG_CXX11
inline void HandShake::set_sclientkey(::std::string&& value) {
  
  sclientkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShake.sClientKey)
}
#endif
inline void HandShake::set_sclientkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShake.sClientKey)
}
inline void HandShake::set_sclientkey(const void* value, size_t size) {
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShake.sClientKey)
}
inline ::std::string* HandShake::mutable_sclientkey() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShake.sClientKey)
  return sclientkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShake::release_sclientkey() {
  // @@protoc_insertion_point(field_release:netData.HandShake.sClientKey)
  
  return sclientkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShake::set_allocated_sclientkey(::std::string* sclientkey) {
  if (sclientkey != NULL) {
    
  } else {
    
  }
  sclientkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sclientkey);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShake.sClientKey)
}

// -------------------------------------------------------------------

// HandShakeRet

// bytes sChallenge = 1;
inline void HandShakeRet::clear_schallenge() {
  schallenge_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShakeRet::schallenge() const {
  // @@protoc_insertion_point(field_get:netData.HandShakeRet.sChallenge)
  return schallenge_.GetNoArena();
}
inline void HandShakeRet::set_schallenge(const ::std::string& value) {
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShakeRet.sChallenge)
}
#if LANG_CXX11
inline void HandShakeRet::set_schallenge(::std::string&& value) {
  
  schallenge_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShakeRet.sChallenge)
}
#endif
inline void HandShakeRet::set_schallenge(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShakeRet.sChallenge)
}
inline void HandShakeRet::set_schallenge(const void* value, size_t size) {
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShakeRet.sChallenge)
}
inline ::std::string* HandShakeRet::mutable_schallenge() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShakeRet.sChallenge)
  return schallenge_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShakeRet::release_schallenge() {
  // @@protoc_insertion_point(field_release:netData.HandShakeRet.sChallenge)
  
  return schallenge_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShakeRet::set_allocated_schallenge(::std::string* schallenge) {
  if (schallenge != NULL) {
    
  } else {
    
  }
  schallenge_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schallenge);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShakeRet.sChallenge)
}

// bytes sServerKey = 2;
inline void HandShakeRet::clear_sserverkey() {
  sserverkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShakeRet::sserverkey() const {
  // @@protoc_insertion_point(field_get:netData.HandShakeRet.sServerKey)
  return sserverkey_.GetNoArena();
}
inline void HandShakeRet::set_sserverkey(const ::std::string& value) {
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShakeRet.sServerKey)
}
#if LANG_CXX11
inline void HandShakeRet::set_sserverkey(::std::string&& value) {
  
  sserverkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShakeRet.sServerKey)
}
#endif
inline void HandShakeRet::set_sserverkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShakeRet.sServerKey)
}
inline void HandShakeRet::set_sserverkey(const void* value, size_t size) {
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShakeRet.sServerKey)
}
inline ::std::string* HandShakeRet::mutable_sserverkey() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShakeRet.sServerKey)
  return sserverkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShakeRet::release_sserverkey() {
  // @@protoc_insertion_point(field_release:netData.HandShakeRet.sServerKey)
  
  return sserverkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShakeRet::set_allocated_sserverkey(::std::string* sserverkey) {
  if (sserverkey != NULL) {
    
  } else {
    
  }
  sserverkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sserverkey);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShakeRet.sServerKey)
}

// -------------------------------------------------------------------

// Challenge

// string sHmac = 1;
inline void Challenge::clear_shmac() {
  shmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Challenge::shmac() const {
  // @@protoc_insertion_point(field_get:netData.Challenge.sHmac)
  return shmac_.GetNoArena();
}
inline void Challenge::set_shmac(const ::std::string& value) {
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Challenge.sHmac)
}
#if LANG_CXX11
inline void Challenge::set_shmac(::std::string&& value) {
  
  shmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Challenge.sHmac)
}
#endif
inline void Challenge::set_shmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Challenge.sHmac)
}
inline void Challenge::set_shmac(const char* value, size_t size) {
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Challenge.sHmac)
}
inline ::std::string* Challenge::mutable_shmac() {
  
  // @@protoc_insertion_point(field_mutable:netData.Challenge.sHmac)
  return shmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Challenge::release_shmac() {
  // @@protoc_insertion_point(field_release:netData.Challenge.sHmac)
  
  return shmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Challenge::set_allocated_shmac(::std::string* shmac) {
  if (shmac != NULL) {
    
  } else {
    
  }
  shmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shmac);
  // @@protoc_insertion_point(field_set_allocated:netData.Challenge.sHmac)
}

// -------------------------------------------------------------------

// ChallengeRet

// int32 nCode = 1;
inline void ChallengeRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 ChallengeRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.ChallengeRet.nCode)
  return ncode_;
}
inline void ChallengeRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.ChallengeRet.nCode)
}

// -------------------------------------------------------------------

// Auth

// string sEtoken = 1;
inline void Auth::clear_setoken() {
  setoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::setoken() const {
  // @@protoc_insertion_point(field_get:netData.Auth.sEtoken)
  return setoken_.GetNoArena();
}
inline void Auth::set_setoken(const ::std::string& value) {
  
  setoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Auth.sEtoken)
}
#if LANG_CXX11
inline void Auth::set_setoken(::std::string&& value) {
  
  setoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Auth.sEtoken)
}
#endif
inline void Auth::set_setoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  setoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Auth.sEtoken)
}
inline void Auth::set_setoken(const char* value, size_t size) {
  
  setoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Auth.sEtoken)
}
inline ::std::string* Auth::mutable_setoken() {
  
  // @@protoc_insertion_point(field_mutable:netData.Auth.sEtoken)
  return setoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_setoken() {
  // @@protoc_insertion_point(field_release:netData.Auth.sEtoken)
  
  return setoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_setoken(::std::string* setoken) {
  if (setoken != NULL) {
    
  } else {
    
  }
  setoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), setoken);
  // @@protoc_insertion_point(field_set_allocated:netData.Auth.sEtoken)
}

// bytes sSecret = 2;
inline void Auth::clear_ssecret() {
  ssecret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::ssecret() const {
  // @@protoc_insertion_point(field_get:netData.Auth.sSecret)
  return ssecret_.GetNoArena();
}
inline void Auth::set_ssecret(const ::std::string& value) {
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Auth.sSecret)
}
#if LANG_CXX11
inline void Auth::set_ssecret(::std::string&& value) {
  
  ssecret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Auth.sSecret)
}
#endif
inline void Auth::set_ssecret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Auth.sSecret)
}
inline void Auth::set_ssecret(const void* value, size_t size) {
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Auth.sSecret)
}
inline ::std::string* Auth::mutable_ssecret() {
  
  // @@protoc_insertion_point(field_mutable:netData.Auth.sSecret)
  return ssecret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_ssecret() {
  // @@protoc_insertion_point(field_release:netData.Auth.sSecret)
  
  return ssecret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_ssecret(::std::string* ssecret) {
  if (ssecret != NULL) {
    
  } else {
    
  }
  ssecret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssecret);
  // @@protoc_insertion_point(field_set_allocated:netData.Auth.sSecret)
}

// -------------------------------------------------------------------

// AuthRet

// int32 nCode = 1;
inline void AuthRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 AuthRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.nCode)
  return ncode_;
}
inline void AuthRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.AuthRet.nCode)
}

// int32 nServerID = 2;
inline void AuthRet::clear_nserverid() {
  nserverid_ = 0;
}
inline ::google::protobuf::int32 AuthRet::nserverid() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.nServerID)
  return nserverid_;
}
inline void AuthRet::set_nserverid(::google::protobuf::int32 value) {
  
  nserverid_ = value;
  // @@protoc_insertion_point(field_set:netData.AuthRet.nServerID)
}

// string ip = 3;
inline void AuthRet::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthRet::ip() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.ip)
  return ip_.GetNoArena();
}
inline void AuthRet::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.AuthRet.ip)
}
#if LANG_CXX11
inline void AuthRet::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.AuthRet.ip)
}
#endif
inline void AuthRet::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.AuthRet.ip)
}
inline void AuthRet::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.AuthRet.ip)
}
inline ::std::string* AuthRet::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:netData.AuthRet.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthRet::release_ip() {
  // @@protoc_insertion_point(field_release:netData.AuthRet.ip)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthRet::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:netData.AuthRet.ip)
}

// int32 port = 4;
inline void AuthRet::clear_port() {
  port_ = 0;
}
inline ::google::protobuf::int32 AuthRet::port() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.port)
  return port_;
}
inline void AuthRet::set_port(::google::protobuf::int32 value) {
  
  port_ = value;
  // @@protoc_insertion_point(field_set:netData.AuthRet.port)
}

// -------------------------------------------------------------------

// Login

// string sToken = 1;
inline void Login::clear_stoken() {
  stoken_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::stoken() const {
  // @@protoc_insertion_point(field_get:netData.Login.sToken)
  return stoken_.GetNoArena();
}
inline void Login::set_stoken(const ::std::string& value) {
  
  stoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Login.sToken)
}
#if LANG_CXX11
inline void Login::set_stoken(::std::string&& value) {
  
  stoken_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Login.sToken)
}
#endif
inline void Login::set_stoken(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  stoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Login.sToken)
}
inline void Login::set_stoken(const char* value, size_t size) {
  
  stoken_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Login.sToken)
}
inline ::std::string* Login::mutable_stoken() {
  
  // @@protoc_insertion_point(field_mutable:netData.Login.sToken)
  return stoken_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_stoken() {
  // @@protoc_insertion_point(field_release:netData.Login.sToken)
  
  return stoken_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_stoken(::std::string* stoken) {
  if (stoken != NULL) {
    
  } else {
    
  }
  stoken_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), stoken);
  // @@protoc_insertion_point(field_set_allocated:netData.Login.sToken)
}

// bytes sSecret = 2;
inline void Login::clear_ssecret() {
  ssecret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::ssecret() const {
  // @@protoc_insertion_point(field_get:netData.Login.sSecret)
  return ssecret_.GetNoArena();
}
inline void Login::set_ssecret(const ::std::string& value) {
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Login.sSecret)
}
#if LANG_CXX11
inline void Login::set_ssecret(::std::string&& value) {
  
  ssecret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Login.sSecret)
}
#endif
inline void Login::set_ssecret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Login.sSecret)
}
inline void Login::set_ssecret(const void* value, size_t size) {
  
  ssecret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Login.sSecret)
}
inline ::std::string* Login::mutable_ssecret() {
  
  // @@protoc_insertion_point(field_mutable:netData.Login.sSecret)
  return ssecret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_ssecret() {
  // @@protoc_insertion_point(field_release:netData.Login.sSecret)
  
  return ssecret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_ssecret(::std::string* ssecret) {
  if (ssecret != NULL) {
    
  } else {
    
  }
  ssecret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssecret);
  // @@protoc_insertion_point(field_set_allocated:netData.Login.sSecret)
}

// -------------------------------------------------------------------

// LoginRet

// int32 nCode = 1;
inline void LoginRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 LoginRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.LoginRet.nCode)
  return ncode_;
}
inline void LoginRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.LoginRet.nCode)
}

// -------------------------------------------------------------------

// PlayerLite

// int64 guid = 1;
inline void PlayerLite::clear_guid() {
  guid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PlayerLite::guid() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.guid)
  return guid_;
}
inline void PlayerLite::set_guid(::google::protobuf::int64 value) {
  
  guid_ = value;
  // @@protoc_insertion_point(field_set:netData.PlayerLite.guid)
}

// string sName = 2;
inline void PlayerLite::clear_sname() {
  sname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerLite::sname() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.sName)
  return sname_.GetNoArena();
}
inline void PlayerLite::set_sname(const ::std::string& value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.PlayerLite.sName)
}
#if LANG_CXX11
inline void PlayerLite::set_sname(::std::string&& value) {
  
  sname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.PlayerLite.sName)
}
#endif
inline void PlayerLite::set_sname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.PlayerLite.sName)
}
inline void PlayerLite::set_sname(const char* value, size_t size) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.PlayerLite.sName)
}
inline ::std::string* PlayerLite::mutable_sname() {
  
  // @@protoc_insertion_point(field_mutable:netData.PlayerLite.sName)
  return sname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerLite::release_sname() {
  // @@protoc_insertion_point(field_release:netData.PlayerLite.sName)
  
  return sname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerLite::set_allocated_sname(::std::string* sname) {
  if (sname != NULL) {
    
  } else {
    
  }
  sname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sname);
  // @@protoc_insertion_point(field_set_allocated:netData.PlayerLite.sName)
}

// int32 nJob = 3;
inline void PlayerLite::clear_njob() {
  njob_ = 0;
}
inline ::google::protobuf::int32 PlayerLite::njob() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.nJob)
  return njob_;
}
inline void PlayerLite::set_njob(::google::protobuf::int32 value) {
  
  njob_ = value;
  // @@protoc_insertion_point(field_set:netData.PlayerLite.nJob)
}

// int32 nSex = 4;
inline void PlayerLite::clear_nsex() {
  nsex_ = 0;
}
inline ::google::protobuf::int32 PlayerLite::nsex() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.nSex)
  return nsex_;
}
inline void PlayerLite::set_nsex(::google::protobuf::int32 value) {
  
  nsex_ = value;
  // @@protoc_insertion_point(field_set:netData.PlayerLite.nSex)
}

// -------------------------------------------------------------------

// PlayerList

// string account = 1;
inline void PlayerList::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerList::account() const {
  // @@protoc_insertion_point(field_get:netData.PlayerList.account)
  return account_.GetNoArena();
}
inline void PlayerList::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.PlayerList.account)
}
#if LANG_CXX11
inline void PlayerList::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.PlayerList.account)
}
#endif
inline void PlayerList::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.PlayerList.account)
}
inline void PlayerList::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.PlayerList.account)
}
inline ::std::string* PlayerList::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:netData.PlayerList.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerList::release_account() {
  // @@protoc_insertion_point(field_release:netData.PlayerList.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerList::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:netData.PlayerList.account)
}

// -------------------------------------------------------------------

// PlayerListRet

// repeated .netData.PlayerLite list = 1;
inline int PlayerListRet::list_size() const {
  return list_.size();
}
inline void PlayerListRet::clear_list() {
  list_.Clear();
}
inline ::netData::PlayerLite* PlayerListRet::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:netData.PlayerListRet.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >*
PlayerListRet::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:netData.PlayerListRet.list)
  return &list_;
}
inline const ::netData::PlayerLite& PlayerListRet::list(int index) const {
  // @@protoc_insertion_point(field_get:netData.PlayerListRet.list)
  return list_.Get(index);
}
inline ::netData::PlayerLite* PlayerListRet::add_list() {
  // @@protoc_insertion_point(field_add:netData.PlayerListRet.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >&
PlayerListRet::list() const {
  // @@protoc_insertion_point(field_list:netData.PlayerListRet.list)
  return list_;
}

// -------------------------------------------------------------------

// CreatePlayer

// string sName = 1;
inline void CreatePlayer::clear_sname() {
  sname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreatePlayer::sname() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.sName)
  return sname_.GetNoArena();
}
inline void CreatePlayer::set_sname(const ::std::string& value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.sName)
}
#if LANG_CXX11
inline void CreatePlayer::set_sname(::std::string&& value) {
  
  sname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.CreatePlayer.sName)
}
#endif
inline void CreatePlayer::set_sname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.CreatePlayer.sName)
}
inline void CreatePlayer::set_sname(const char* value, size_t size) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.CreatePlayer.sName)
}
inline ::std::string* CreatePlayer::mutable_sname() {
  
  // @@protoc_insertion_point(field_mutable:netData.CreatePlayer.sName)
  return sname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatePlayer::release_sname() {
  // @@protoc_insertion_point(field_release:netData.CreatePlayer.sName)
  
  return sname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatePlayer::set_allocated_sname(::std::string* sname) {
  if (sname != NULL) {
    
  } else {
    
  }
  sname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sname);
  // @@protoc_insertion_point(field_set_allocated:netData.CreatePlayer.sName)
}

// int32 nJob = 2;
inline void CreatePlayer::clear_njob() {
  njob_ = 0;
}
inline ::google::protobuf::int32 CreatePlayer::njob() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.nJob)
  return njob_;
}
inline void CreatePlayer::set_njob(::google::protobuf::int32 value) {
  
  njob_ = value;
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.nJob)
}

// int32 nSex = 3;
inline void CreatePlayer::clear_nsex() {
  nsex_ = 0;
}
inline ::google::protobuf::int32 CreatePlayer::nsex() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.nSex)
  return nsex_;
}
inline void CreatePlayer::set_nsex(::google::protobuf::int32 value) {
  
  nsex_ = value;
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.nSex)
}

// string account = 4;
inline void CreatePlayer::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreatePlayer::account() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.account)
  return account_.GetNoArena();
}
inline void CreatePlayer::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.account)
}
#if LANG_CXX11
inline void CreatePlayer::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.CreatePlayer.account)
}
#endif
inline void CreatePlayer::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.CreatePlayer.account)
}
inline void CreatePlayer::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.CreatePlayer.account)
}
inline ::std::string* CreatePlayer::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:netData.CreatePlayer.account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatePlayer::release_account() {
  // @@protoc_insertion_point(field_release:netData.CreatePlayer.account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatePlayer::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:netData.CreatePlayer.account)
}

// -------------------------------------------------------------------

// CreatePlayerRet

// int32 nCode = 1;
inline void CreatePlayerRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 CreatePlayerRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayerRet.nCode)
  return ncode_;
}
inline void CreatePlayerRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.CreatePlayerRet.nCode)
}

// .netData.PlayerLite info = 2;
inline bool CreatePlayerRet::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void CreatePlayerRet::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::netData::PlayerLite& CreatePlayerRet::info() const {
  const ::netData::PlayerLite* p = info_;
  // @@protoc_insertion_point(field_get:netData.CreatePlayerRet.info)
  return p != NULL ? *p : *reinterpret_cast<const ::netData::PlayerLite*>(
      &::netData::_PlayerLite_default_instance_);
}
inline ::netData::PlayerLite* CreatePlayerRet::release_info() {
  // @@protoc_insertion_point(field_release:netData.CreatePlayerRet.info)
  
  ::netData::PlayerLite* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::netData::PlayerLite* CreatePlayerRet::mutable_info() {
  
  if (info_ == NULL) {
    info_ = ::google::protobuf::Arena::Create< ::netData::PlayerLite >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netData.CreatePlayerRet.info)
  return info_;
}
inline void CreatePlayerRet::set_allocated_info(::netData::PlayerLite* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:netData.CreatePlayerRet.info)
}

// -------------------------------------------------------------------

// SelectPlayer

// int64 guid = 1;
inline void SelectPlayer::clear_guid() {
  guid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SelectPlayer::guid() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayer.guid)
  return guid_;
}
inline void SelectPlayer::set_guid(::google::protobuf::int64 value) {
  
  guid_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayer.guid)
}

// -------------------------------------------------------------------

// SelectPlayerRet

// int32 nCode = 1;
inline void SelectPlayerRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 SelectPlayerRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayerRet.nCode)
  return ncode_;
}
inline void SelectPlayerRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayerRet.nCode)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace netData

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::netData::ChallengeRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::ChallengeRet_EC>() {
  return ::netData::ChallengeRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::AuthRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::AuthRet_EC>() {
  return ::netData::AuthRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::LoginRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::LoginRet_EC>() {
  return ::netData::LoginRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::CreatePlayerRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::CreatePlayerRet_EC>() {
  return ::netData::CreatePlayerRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::SelectPlayerRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::SelectPlayerRet_EC>() {
  return ::netData::SelectPlayerRet_EC_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Login_2eproto_INCLUDED
