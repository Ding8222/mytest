// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Login.proto

#ifndef PROTOBUF_Login_2eproto_INCLUDED
#define PROTOBUF_Login_2eproto_INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_Login_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsHandShakeImpl();
void InitDefaultsHandShake();
void InitDefaultsHandShakeRetImpl();
void InitDefaultsHandShakeRet();
void InitDefaultsChallengeImpl();
void InitDefaultsChallenge();
void InitDefaultsChallengeRetImpl();
void InitDefaultsChallengeRet();
void InitDefaultsAuthImpl();
void InitDefaultsAuth();
void InitDefaultsAuthRetImpl();
void InitDefaultsAuthRet();
void InitDefaultsLoginImpl();
void InitDefaultsLogin();
void InitDefaultsLoginRetImpl();
void InitDefaultsLoginRet();
void InitDefaultsPlayerLiteImpl();
void InitDefaultsPlayerLite();
void InitDefaultsPlayerListImpl();
void InitDefaultsPlayerList();
void InitDefaultsPlayerListRetImpl();
void InitDefaultsPlayerListRet();
void InitDefaultsCreatePlayerImpl();
void InitDefaultsCreatePlayer();
void InitDefaultsCreatePlayerRetImpl();
void InitDefaultsCreatePlayerRet();
void InitDefaultsSelectPlayerImpl();
void InitDefaultsSelectPlayer();
void InitDefaultsSelectPlayerRetImpl();
void InitDefaultsSelectPlayerRet();
inline void InitDefaults() {
  InitDefaultsHandShake();
  InitDefaultsHandShakeRet();
  InitDefaultsChallenge();
  InitDefaultsChallengeRet();
  InitDefaultsAuth();
  InitDefaultsAuthRet();
  InitDefaultsLogin();
  InitDefaultsLoginRet();
  InitDefaultsPlayerLite();
  InitDefaultsPlayerList();
  InitDefaultsPlayerListRet();
  InitDefaultsCreatePlayer();
  InitDefaultsCreatePlayerRet();
  InitDefaultsSelectPlayer();
  InitDefaultsSelectPlayerRet();
}
}  // namespace protobuf_Login_2eproto
namespace netData {
class Auth;
class AuthDefaultTypeInternal;
extern AuthDefaultTypeInternal _Auth_default_instance_;
class AuthRet;
class AuthRetDefaultTypeInternal;
extern AuthRetDefaultTypeInternal _AuthRet_default_instance_;
class Challenge;
class ChallengeDefaultTypeInternal;
extern ChallengeDefaultTypeInternal _Challenge_default_instance_;
class ChallengeRet;
class ChallengeRetDefaultTypeInternal;
extern ChallengeRetDefaultTypeInternal _ChallengeRet_default_instance_;
class CreatePlayer;
class CreatePlayerDefaultTypeInternal;
extern CreatePlayerDefaultTypeInternal _CreatePlayer_default_instance_;
class CreatePlayerRet;
class CreatePlayerRetDefaultTypeInternal;
extern CreatePlayerRetDefaultTypeInternal _CreatePlayerRet_default_instance_;
class HandShake;
class HandShakeDefaultTypeInternal;
extern HandShakeDefaultTypeInternal _HandShake_default_instance_;
class HandShakeRet;
class HandShakeRetDefaultTypeInternal;
extern HandShakeRetDefaultTypeInternal _HandShakeRet_default_instance_;
class Login;
class LoginDefaultTypeInternal;
extern LoginDefaultTypeInternal _Login_default_instance_;
class LoginRet;
class LoginRetDefaultTypeInternal;
extern LoginRetDefaultTypeInternal _LoginRet_default_instance_;
class PlayerList;
class PlayerListDefaultTypeInternal;
extern PlayerListDefaultTypeInternal _PlayerList_default_instance_;
class PlayerListRet;
class PlayerListRetDefaultTypeInternal;
extern PlayerListRetDefaultTypeInternal _PlayerListRet_default_instance_;
class PlayerLite;
class PlayerLiteDefaultTypeInternal;
extern PlayerLiteDefaultTypeInternal _PlayerLite_default_instance_;
class SelectPlayer;
class SelectPlayerDefaultTypeInternal;
extern SelectPlayerDefaultTypeInternal _SelectPlayer_default_instance_;
class SelectPlayerRet;
class SelectPlayerRetDefaultTypeInternal;
extern SelectPlayerRetDefaultTypeInternal _SelectPlayerRet_default_instance_;
}  // namespace netData
namespace google {
namespace protobuf {
template<> ::netData::Auth* Arena::Create< ::netData::Auth>(Arena*);
template<> ::netData::AuthRet* Arena::Create< ::netData::AuthRet>(Arena*);
template<> ::netData::Challenge* Arena::Create< ::netData::Challenge>(Arena*);
template<> ::netData::ChallengeRet* Arena::Create< ::netData::ChallengeRet>(Arena*);
template<> ::netData::CreatePlayer* Arena::Create< ::netData::CreatePlayer>(Arena*);
template<> ::netData::CreatePlayerRet* Arena::Create< ::netData::CreatePlayerRet>(Arena*);
template<> ::netData::HandShake* Arena::Create< ::netData::HandShake>(Arena*);
template<> ::netData::HandShakeRet* Arena::Create< ::netData::HandShakeRet>(Arena*);
template<> ::netData::Login* Arena::Create< ::netData::Login>(Arena*);
template<> ::netData::LoginRet* Arena::Create< ::netData::LoginRet>(Arena*);
template<> ::netData::PlayerList* Arena::Create< ::netData::PlayerList>(Arena*);
template<> ::netData::PlayerListRet* Arena::Create< ::netData::PlayerListRet>(Arena*);
template<> ::netData::PlayerLite* Arena::Create< ::netData::PlayerLite>(Arena*);
template<> ::netData::SelectPlayer* Arena::Create< ::netData::SelectPlayer>(Arena*);
template<> ::netData::SelectPlayerRet* Arena::Create< ::netData::SelectPlayerRet>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace netData {

enum HandShakeRet_EC {
  HandShakeRet_EC_EC_OTHER = 0,
  HandShakeRet_EC_EC_SUCC = 1,
  HandShakeRet_EC_EC_FAIL = 2,
  HandShakeRet_EC_HandShakeRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HandShakeRet_EC_HandShakeRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HandShakeRet_EC_IsValid(int value);
const HandShakeRet_EC HandShakeRet_EC_EC_MIN = HandShakeRet_EC_EC_OTHER;
const HandShakeRet_EC HandShakeRet_EC_EC_MAX = HandShakeRet_EC_EC_FAIL;
const int HandShakeRet_EC_EC_ARRAYSIZE = HandShakeRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* HandShakeRet_EC_descriptor();
inline const ::std::string& HandShakeRet_EC_Name(HandShakeRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    HandShakeRet_EC_descriptor(), value);
}
inline bool HandShakeRet_EC_Parse(
    const ::std::string& name, HandShakeRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HandShakeRet_EC>(
    HandShakeRet_EC_descriptor(), name, value);
}
enum ChallengeRet_EC {
  ChallengeRet_EC_EC_OTHER = 0,
  ChallengeRet_EC_EC_SUCC = 1,
  ChallengeRet_EC_EC_FAIL = 2,
  ChallengeRet_EC_ChallengeRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ChallengeRet_EC_ChallengeRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ChallengeRet_EC_IsValid(int value);
const ChallengeRet_EC ChallengeRet_EC_EC_MIN = ChallengeRet_EC_EC_OTHER;
const ChallengeRet_EC ChallengeRet_EC_EC_MAX = ChallengeRet_EC_EC_FAIL;
const int ChallengeRet_EC_EC_ARRAYSIZE = ChallengeRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChallengeRet_EC_descriptor();
inline const ::std::string& ChallengeRet_EC_Name(ChallengeRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChallengeRet_EC_descriptor(), value);
}
inline bool ChallengeRet_EC_Parse(
    const ::std::string& name, ChallengeRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChallengeRet_EC>(
    ChallengeRet_EC_descriptor(), name, value);
}
enum AuthRet_EC {
  AuthRet_EC_EC_OTHER = 0,
  AuthRet_EC_EC_SUCC = 1,
  AuthRet_EC_EC_FAIL = 2,
  AuthRet_EC_EC_HANDSHAKE = 3,
  AuthRet_EC_EC_ADDACCOUNT = 4,
  AuthRet_EC_EC_DB = 5,
  AuthRet_EC_EC_AUTHINFO = 6,
  AuthRet_EC_EC_AUTHING = 7,
  AuthRet_EC_EC_KICK = 8,
  AuthRet_EC_EC_WATING = 9,
  AuthRet_EC_EC_LOGINTIME = 10,
  AuthRet_EC_EC_CREATE = 11,
  AuthRet_EC_AuthRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AuthRet_EC_AuthRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AuthRet_EC_IsValid(int value);
const AuthRet_EC AuthRet_EC_EC_MIN = AuthRet_EC_EC_OTHER;
const AuthRet_EC AuthRet_EC_EC_MAX = AuthRet_EC_EC_CREATE;
const int AuthRet_EC_EC_ARRAYSIZE = AuthRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthRet_EC_descriptor();
inline const ::std::string& AuthRet_EC_Name(AuthRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthRet_EC_descriptor(), value);
}
inline bool AuthRet_EC_Parse(
    const ::std::string& name, AuthRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthRet_EC>(
    AuthRet_EC_descriptor(), name, value);
}
enum LoginRet_EC {
  LoginRet_EC_EC_OTHER = 0,
  LoginRet_EC_EC_SUCC = 1,
  LoginRet_EC_EC_FAIL = 2,
  LoginRet_EC_EC_ACCOUNT = 3,
  LoginRet_EC_EC_SECRET = 4,
  LoginRet_EC_EC_CENTERID = 5,
  LoginRet_EC_EC_ADDPLAYER = 6,
  LoginRet_EC_EC_LOADDATA = 7,
  LoginRet_EC_LoginRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoginRet_EC_LoginRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoginRet_EC_IsValid(int value);
const LoginRet_EC LoginRet_EC_EC_MIN = LoginRet_EC_EC_OTHER;
const LoginRet_EC LoginRet_EC_EC_MAX = LoginRet_EC_EC_LOADDATA;
const int LoginRet_EC_EC_ARRAYSIZE = LoginRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginRet_EC_descriptor();
inline const ::std::string& LoginRet_EC_Name(LoginRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginRet_EC_descriptor(), value);
}
inline bool LoginRet_EC_Parse(
    const ::std::string& name, LoginRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginRet_EC>(
    LoginRet_EC_descriptor(), name, value);
}
enum CreatePlayerRet_EC {
  CreatePlayerRet_EC_EC_OTHER = 0,
  CreatePlayerRet_EC_EC_SUCC = 1,
  CreatePlayerRet_EC_EC_FAIL = 2,
  CreatePlayerRet_EC_EC_CREATE = 3,
  CreatePlayerRet_EC_CreatePlayerRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CreatePlayerRet_EC_CreatePlayerRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CreatePlayerRet_EC_IsValid(int value);
const CreatePlayerRet_EC CreatePlayerRet_EC_EC_MIN = CreatePlayerRet_EC_EC_OTHER;
const CreatePlayerRet_EC CreatePlayerRet_EC_EC_MAX = CreatePlayerRet_EC_EC_CREATE;
const int CreatePlayerRet_EC_EC_ARRAYSIZE = CreatePlayerRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* CreatePlayerRet_EC_descriptor();
inline const ::std::string& CreatePlayerRet_EC_Name(CreatePlayerRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    CreatePlayerRet_EC_descriptor(), value);
}
inline bool CreatePlayerRet_EC_Parse(
    const ::std::string& name, CreatePlayerRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CreatePlayerRet_EC>(
    CreatePlayerRet_EC_descriptor(), name, value);
}
enum SelectPlayerRet_EC {
  SelectPlayerRet_EC_EC_OTHER = 0,
  SelectPlayerRet_EC_EC_SUCC = 1,
  SelectPlayerRet_EC_EC_FAIL = 2,
  SelectPlayerRet_EC_EC_SERVER = 3,
  SelectPlayerRet_EC_EC_AUTH = 4,
  SelectPlayerRet_EC_EC_NONE = 5,
  SelectPlayerRet_EC_EC_LOGINTIME = 6,
  SelectPlayerRet_EC_SelectPlayerRet_EC_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SelectPlayerRet_EC_SelectPlayerRet_EC_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SelectPlayerRet_EC_IsValid(int value);
const SelectPlayerRet_EC SelectPlayerRet_EC_EC_MIN = SelectPlayerRet_EC_EC_OTHER;
const SelectPlayerRet_EC SelectPlayerRet_EC_EC_MAX = SelectPlayerRet_EC_EC_LOGINTIME;
const int SelectPlayerRet_EC_EC_ARRAYSIZE = SelectPlayerRet_EC_EC_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectPlayerRet_EC_descriptor();
inline const ::std::string& SelectPlayerRet_EC_Name(SelectPlayerRet_EC value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectPlayerRet_EC_descriptor(), value);
}
inline bool SelectPlayerRet_EC_Parse(
    const ::std::string& name, SelectPlayerRet_EC* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectPlayerRet_EC>(
    SelectPlayerRet_EC_descriptor(), name, value);
}
// ===================================================================

class HandShake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.HandShake) */ {
 public:
  HandShake();
  virtual ~HandShake();

  HandShake(const HandShake& from);

  inline HandShake& operator=(const HandShake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandShake(HandShake&& from) noexcept
    : HandShake() {
    *this = ::std::move(from);
  }

  inline HandShake& operator=(HandShake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandShake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandShake* internal_default_instance() {
    return reinterpret_cast<const HandShake*>(
               &_HandShake_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HandShake* other);
  friend void swap(HandShake& a, HandShake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandShake* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShake>(NULL);
  }

  HandShake* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HandShake& from);
  void MergeFrom(const HandShake& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HandShake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes sClientKey = 1;
  void clear_sclientkey();
  static const int kSClientKeyFieldNumber = 1;
  const ::std::string& sclientkey() const;
  void set_sclientkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sclientkey(::std::string&& value);
  #endif
  void set_sclientkey(const char* value);
  void set_sclientkey(const void* value, size_t size);
  ::std::string* mutable_sclientkey();
  ::std::string* release_sclientkey();
  void set_allocated_sclientkey(::std::string* sclientkey);

  // @@protoc_insertion_point(class_scope:netData.HandShake)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sclientkey_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsHandShakeImpl();
};
// -------------------------------------------------------------------

class HandShakeRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.HandShakeRet) */ {
 public:
  HandShakeRet();
  virtual ~HandShakeRet();

  HandShakeRet(const HandShakeRet& from);

  inline HandShakeRet& operator=(const HandShakeRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HandShakeRet(HandShakeRet&& from) noexcept
    : HandShakeRet() {
    *this = ::std::move(from);
  }

  inline HandShakeRet& operator=(HandShakeRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HandShakeRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HandShakeRet* internal_default_instance() {
    return reinterpret_cast<const HandShakeRet*>(
               &_HandShakeRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(HandShakeRet* other);
  friend void swap(HandShakeRet& a, HandShakeRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HandShakeRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShakeRet>(NULL);
  }

  HandShakeRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<HandShakeRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HandShakeRet& from);
  void MergeFrom(const HandShakeRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HandShakeRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef HandShakeRet_EC EC;
  static const EC EC_OTHER =
    HandShakeRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    HandShakeRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    HandShakeRet_EC_EC_FAIL;
  static inline bool EC_IsValid(int value) {
    return HandShakeRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    HandShakeRet_EC_EC_MIN;
  static const EC EC_MAX =
    HandShakeRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    HandShakeRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return HandShakeRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return HandShakeRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return HandShakeRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes sChallenge = 2;
  void clear_schallenge();
  static const int kSChallengeFieldNumber = 2;
  const ::std::string& schallenge() const;
  void set_schallenge(const ::std::string& value);
  #if LANG_CXX11
  void set_schallenge(::std::string&& value);
  #endif
  void set_schallenge(const char* value);
  void set_schallenge(const void* value, size_t size);
  ::std::string* mutable_schallenge();
  ::std::string* release_schallenge();
  void set_allocated_schallenge(::std::string* schallenge);

  // bytes sServerKey = 3;
  void clear_sserverkey();
  static const int kSServerKeyFieldNumber = 3;
  const ::std::string& sserverkey() const;
  void set_sserverkey(const ::std::string& value);
  #if LANG_CXX11
  void set_sserverkey(::std::string&& value);
  #endif
  void set_sserverkey(const char* value);
  void set_sserverkey(const void* value, size_t size);
  ::std::string* mutable_sserverkey();
  ::std::string* release_sserverkey();
  void set_allocated_sserverkey(::std::string* sserverkey);

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.HandShakeRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr schallenge_;
  ::google::protobuf::internal::ArenaStringPtr sserverkey_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsHandShakeRetImpl();
};
// -------------------------------------------------------------------

class Challenge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Challenge) */ {
 public:
  Challenge();
  virtual ~Challenge();

  Challenge(const Challenge& from);

  inline Challenge& operator=(const Challenge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Challenge(Challenge&& from) noexcept
    : Challenge() {
    *this = ::std::move(from);
  }

  inline Challenge& operator=(Challenge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Challenge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Challenge* internal_default_instance() {
    return reinterpret_cast<const Challenge*>(
               &_Challenge_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Challenge* other);
  friend void swap(Challenge& a, Challenge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Challenge* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Challenge>(NULL);
  }

  Challenge* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Challenge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Challenge& from);
  void MergeFrom(const Challenge& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Challenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sHmac = 1;
  void clear_shmac();
  static const int kSHmacFieldNumber = 1;
  const ::std::string& shmac() const;
  void set_shmac(const ::std::string& value);
  #if LANG_CXX11
  void set_shmac(::std::string&& value);
  #endif
  void set_shmac(const char* value);
  void set_shmac(const char* value, size_t size);
  ::std::string* mutable_shmac();
  ::std::string* release_shmac();
  void set_allocated_shmac(::std::string* shmac);

  // @@protoc_insertion_point(class_scope:netData.Challenge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr shmac_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsChallengeImpl();
};
// -------------------------------------------------------------------

class ChallengeRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.ChallengeRet) */ {
 public:
  ChallengeRet();
  virtual ~ChallengeRet();

  ChallengeRet(const ChallengeRet& from);

  inline ChallengeRet& operator=(const ChallengeRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ChallengeRet(ChallengeRet&& from) noexcept
    : ChallengeRet() {
    *this = ::std::move(from);
  }

  inline ChallengeRet& operator=(ChallengeRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ChallengeRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ChallengeRet* internal_default_instance() {
    return reinterpret_cast<const ChallengeRet*>(
               &_ChallengeRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(ChallengeRet* other);
  friend void swap(ChallengeRet& a, ChallengeRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ChallengeRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ChallengeRet>(NULL);
  }

  ChallengeRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<ChallengeRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ChallengeRet& from);
  void MergeFrom(const ChallengeRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ChallengeRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef ChallengeRet_EC EC;
  static const EC EC_OTHER =
    ChallengeRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    ChallengeRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    ChallengeRet_EC_EC_FAIL;
  static inline bool EC_IsValid(int value) {
    return ChallengeRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    ChallengeRet_EC_EC_MIN;
  static const EC EC_MAX =
    ChallengeRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    ChallengeRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return ChallengeRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return ChallengeRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return ChallengeRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.ChallengeRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsChallengeRetImpl();
};
// -------------------------------------------------------------------

class Auth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Auth) */ {
 public:
  Auth();
  virtual ~Auth();

  Auth(const Auth& from);

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Auth(Auth&& from) noexcept
    : Auth() {
    *this = ::std::move(from);
  }

  inline Auth& operator=(Auth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Auth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Auth* internal_default_instance() {
    return reinterpret_cast<const Auth*>(
               &_Auth_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(Auth* other);
  friend void swap(Auth& a, Auth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Auth* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Auth>(NULL);
  }

  Auth* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Auth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Auth& from);
  void MergeFrom(const Auth& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Auth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // bytes Secret = 2;
  void clear_secret();
  static const int kSecretFieldNumber = 2;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:netData.Auth)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsAuthImpl();
};
// -------------------------------------------------------------------

class AuthRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.AuthRet) */ {
 public:
  AuthRet();
  virtual ~AuthRet();

  AuthRet(const AuthRet& from);

  inline AuthRet& operator=(const AuthRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthRet(AuthRet&& from) noexcept
    : AuthRet() {
    *this = ::std::move(from);
  }

  inline AuthRet& operator=(AuthRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthRet* internal_default_instance() {
    return reinterpret_cast<const AuthRet*>(
               &_AuthRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AuthRet* other);
  friend void swap(AuthRet& a, AuthRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AuthRet>(NULL);
  }

  AuthRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<AuthRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AuthRet& from);
  void MergeFrom(const AuthRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AuthRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AuthRet_EC EC;
  static const EC EC_OTHER =
    AuthRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    AuthRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    AuthRet_EC_EC_FAIL;
  static const EC EC_HANDSHAKE =
    AuthRet_EC_EC_HANDSHAKE;
  static const EC EC_ADDACCOUNT =
    AuthRet_EC_EC_ADDACCOUNT;
  static const EC EC_DB =
    AuthRet_EC_EC_DB;
  static const EC EC_AUTHINFO =
    AuthRet_EC_EC_AUTHINFO;
  static const EC EC_AUTHING =
    AuthRet_EC_EC_AUTHING;
  static const EC EC_KICK =
    AuthRet_EC_EC_KICK;
  static const EC EC_WATING =
    AuthRet_EC_EC_WATING;
  static const EC EC_LOGINTIME =
    AuthRet_EC_EC_LOGINTIME;
  static const EC EC_CREATE =
    AuthRet_EC_EC_CREATE;
  static inline bool EC_IsValid(int value) {
    return AuthRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    AuthRet_EC_EC_MIN;
  static const EC EC_MAX =
    AuthRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    AuthRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return AuthRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return AuthRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return AuthRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string Account = 2;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.AuthRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsAuthRetImpl();
};
// -------------------------------------------------------------------

class Login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.Login) */ {
 public:
  Login();
  virtual ~Login();

  Login(const Login& from);

  inline Login& operator=(const Login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Login(Login&& from) noexcept
    : Login() {
    *this = ::std::move(from);
  }

  inline Login& operator=(Login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Login& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Login* internal_default_instance() {
    return reinterpret_cast<const Login*>(
               &_Login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Login* other);
  friend void swap(Login& a, Login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Login* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Login>(NULL);
  }

  Login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<Login>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Login& from);
  void MergeFrom(const Login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // bytes Secret = 2;
  void clear_secret();
  static const int kSecretFieldNumber = 2;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const void* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:netData.Login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsLoginImpl();
};
// -------------------------------------------------------------------

class LoginRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.LoginRet) */ {
 public:
  LoginRet();
  virtual ~LoginRet();

  LoginRet(const LoginRet& from);

  inline LoginRet& operator=(const LoginRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LoginRet(LoginRet&& from) noexcept
    : LoginRet() {
    *this = ::std::move(from);
  }

  inline LoginRet& operator=(LoginRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LoginRet* internal_default_instance() {
    return reinterpret_cast<const LoginRet*>(
               &_LoginRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(LoginRet* other);
  friend void swap(LoginRet& a, LoginRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LoginRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginRet>(NULL);
  }

  LoginRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<LoginRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LoginRet& from);
  void MergeFrom(const LoginRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LoginRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LoginRet_EC EC;
  static const EC EC_OTHER =
    LoginRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    LoginRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    LoginRet_EC_EC_FAIL;
  static const EC EC_ACCOUNT =
    LoginRet_EC_EC_ACCOUNT;
  static const EC EC_SECRET =
    LoginRet_EC_EC_SECRET;
  static const EC EC_CENTERID =
    LoginRet_EC_EC_CENTERID;
  static const EC EC_ADDPLAYER =
    LoginRet_EC_EC_ADDPLAYER;
  static const EC EC_LOADDATA =
    LoginRet_EC_EC_LOADDATA;
  static inline bool EC_IsValid(int value) {
    return LoginRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    LoginRet_EC_EC_MIN;
  static const EC EC_MAX =
    LoginRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    LoginRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return LoginRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return LoginRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return LoginRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // int32 nTempID = 2;
  void clear_ntempid();
  static const int kNTempIDFieldNumber = 2;
  ::google::protobuf::int32 ntempid() const;
  void set_ntempid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.LoginRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 ncode_;
  ::google::protobuf::int32 ntempid_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsLoginRetImpl();
};
// -------------------------------------------------------------------

class PlayerLite : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.PlayerLite) */ {
 public:
  PlayerLite();
  virtual ~PlayerLite();

  PlayerLite(const PlayerLite& from);

  inline PlayerLite& operator=(const PlayerLite& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerLite(PlayerLite&& from) noexcept
    : PlayerLite() {
    *this = ::std::move(from);
  }

  inline PlayerLite& operator=(PlayerLite&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerLite& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerLite* internal_default_instance() {
    return reinterpret_cast<const PlayerLite*>(
               &_PlayerLite_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(PlayerLite* other);
  friend void swap(PlayerLite& a, PlayerLite& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerLite* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerLite>(NULL);
  }

  PlayerLite* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerLite>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerLite& from);
  void MergeFrom(const PlayerLite& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerLite* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sName = 2;
  void clear_sname();
  static const int kSNameFieldNumber = 2;
  const ::std::string& sname() const;
  void set_sname(const ::std::string& value);
  #if LANG_CXX11
  void set_sname(::std::string&& value);
  #endif
  void set_sname(const char* value);
  void set_sname(const char* value, size_t size);
  ::std::string* mutable_sname();
  ::std::string* release_sname();
  void set_allocated_sname(::std::string* sname);

  // int64 nGuid = 1;
  void clear_nguid();
  static const int kNGuidFieldNumber = 1;
  ::google::protobuf::int64 nguid() const;
  void set_nguid(::google::protobuf::int64 value);

  // int32 nJob = 3;
  void clear_njob();
  static const int kNJobFieldNumber = 3;
  ::google::protobuf::int32 njob() const;
  void set_njob(::google::protobuf::int32 value);

  // int32 nSex = 4;
  void clear_nsex();
  static const int kNSexFieldNumber = 4;
  ::google::protobuf::int32 nsex() const;
  void set_nsex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.PlayerLite)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sname_;
  ::google::protobuf::int64 nguid_;
  ::google::protobuf::int32 njob_;
  ::google::protobuf::int32 nsex_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsPlayerLiteImpl();
};
// -------------------------------------------------------------------

class PlayerList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.PlayerList) */ {
 public:
  PlayerList();
  virtual ~PlayerList();

  PlayerList(const PlayerList& from);

  inline PlayerList& operator=(const PlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerList(PlayerList&& from) noexcept
    : PlayerList() {
    *this = ::std::move(from);
  }

  inline PlayerList& operator=(PlayerList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerList* internal_default_instance() {
    return reinterpret_cast<const PlayerList*>(
               &_PlayerList_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PlayerList* other);
  friend void swap(PlayerList& a, PlayerList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerList* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerList>(NULL);
  }

  PlayerList* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerList& from);
  void MergeFrom(const PlayerList& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string Account = 1;
  void clear_account();
  static const int kAccountFieldNumber = 1;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // @@protoc_insertion_point(class_scope:netData.PlayerList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsPlayerListImpl();
};
// -------------------------------------------------------------------

class PlayerListRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.PlayerListRet) */ {
 public:
  PlayerListRet();
  virtual ~PlayerListRet();

  PlayerListRet(const PlayerListRet& from);

  inline PlayerListRet& operator=(const PlayerListRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlayerListRet(PlayerListRet&& from) noexcept
    : PlayerListRet() {
    *this = ::std::move(from);
  }

  inline PlayerListRet& operator=(PlayerListRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerListRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlayerListRet* internal_default_instance() {
    return reinterpret_cast<const PlayerListRet*>(
               &_PlayerListRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(PlayerListRet* other);
  friend void swap(PlayerListRet& a, PlayerListRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlayerListRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerListRet>(NULL);
  }

  PlayerListRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<PlayerListRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PlayerListRet& from);
  void MergeFrom(const PlayerListRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PlayerListRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .netData.PlayerLite list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::netData::PlayerLite* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >*
      mutable_list();
  const ::netData::PlayerLite& list(int index) const;
  ::netData::PlayerLite* add_list();
  const ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >&
      list() const;

  // @@protoc_insertion_point(class_scope:netData.PlayerListRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite > list_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsPlayerListRetImpl();
};
// -------------------------------------------------------------------

class CreatePlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.CreatePlayer) */ {
 public:
  CreatePlayer();
  virtual ~CreatePlayer();

  CreatePlayer(const CreatePlayer& from);

  inline CreatePlayer& operator=(const CreatePlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatePlayer(CreatePlayer&& from) noexcept
    : CreatePlayer() {
    *this = ::std::move(from);
  }

  inline CreatePlayer& operator=(CreatePlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatePlayer* internal_default_instance() {
    return reinterpret_cast<const CreatePlayer*>(
               &_CreatePlayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(CreatePlayer* other);
  friend void swap(CreatePlayer& a, CreatePlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatePlayer* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayer>(NULL);
  }

  CreatePlayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreatePlayer& from);
  void MergeFrom(const CreatePlayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreatePlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sName = 1;
  void clear_sname();
  static const int kSNameFieldNumber = 1;
  const ::std::string& sname() const;
  void set_sname(const ::std::string& value);
  #if LANG_CXX11
  void set_sname(::std::string&& value);
  #endif
  void set_sname(const char* value);
  void set_sname(const char* value, size_t size);
  ::std::string* mutable_sname();
  ::std::string* release_sname();
  void set_allocated_sname(::std::string* sname);

  // string Account = 4;
  void clear_account();
  static const int kAccountFieldNumber = 4;
  const ::std::string& account() const;
  void set_account(const ::std::string& value);
  #if LANG_CXX11
  void set_account(::std::string&& value);
  #endif
  void set_account(const char* value);
  void set_account(const char* value, size_t size);
  ::std::string* mutable_account();
  ::std::string* release_account();
  void set_allocated_account(::std::string* account);

  // int32 nJob = 2;
  void clear_njob();
  static const int kNJobFieldNumber = 2;
  ::google::protobuf::int32 njob() const;
  void set_njob(::google::protobuf::int32 value);

  // int32 nSex = 3;
  void clear_nsex();
  static const int kNSexFieldNumber = 3;
  ::google::protobuf::int32 nsex() const;
  void set_nsex(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.CreatePlayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sname_;
  ::google::protobuf::internal::ArenaStringPtr account_;
  ::google::protobuf::int32 njob_;
  ::google::protobuf::int32 nsex_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsCreatePlayerImpl();
};
// -------------------------------------------------------------------

class CreatePlayerRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.CreatePlayerRet) */ {
 public:
  CreatePlayerRet();
  virtual ~CreatePlayerRet();

  CreatePlayerRet(const CreatePlayerRet& from);

  inline CreatePlayerRet& operator=(const CreatePlayerRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatePlayerRet(CreatePlayerRet&& from) noexcept
    : CreatePlayerRet() {
    *this = ::std::move(from);
  }

  inline CreatePlayerRet& operator=(CreatePlayerRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePlayerRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatePlayerRet* internal_default_instance() {
    return reinterpret_cast<const CreatePlayerRet*>(
               &_CreatePlayerRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(CreatePlayerRet* other);
  friend void swap(CreatePlayerRet& a, CreatePlayerRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatePlayerRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayerRet>(NULL);
  }

  CreatePlayerRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<CreatePlayerRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CreatePlayerRet& from);
  void MergeFrom(const CreatePlayerRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CreatePlayerRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CreatePlayerRet_EC EC;
  static const EC EC_OTHER =
    CreatePlayerRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    CreatePlayerRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    CreatePlayerRet_EC_EC_FAIL;
  static const EC EC_CREATE =
    CreatePlayerRet_EC_EC_CREATE;
  static inline bool EC_IsValid(int value) {
    return CreatePlayerRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    CreatePlayerRet_EC_EC_MIN;
  static const EC EC_MAX =
    CreatePlayerRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    CreatePlayerRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return CreatePlayerRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return CreatePlayerRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return CreatePlayerRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .netData.PlayerLite Info = 2;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 2;
  const ::netData::PlayerLite& info() const;
  ::netData::PlayerLite* release_info();
  ::netData::PlayerLite* mutable_info();
  void set_allocated_info(::netData::PlayerLite* info);

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.CreatePlayerRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::netData::PlayerLite* info_;
  ::google::protobuf::int32 ncode_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsCreatePlayerRetImpl();
};
// -------------------------------------------------------------------

class SelectPlayer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.SelectPlayer) */ {
 public:
  SelectPlayer();
  virtual ~SelectPlayer();

  SelectPlayer(const SelectPlayer& from);

  inline SelectPlayer& operator=(const SelectPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectPlayer(SelectPlayer&& from) noexcept
    : SelectPlayer() {
    *this = ::std::move(from);
  }

  inline SelectPlayer& operator=(SelectPlayer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectPlayer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectPlayer* internal_default_instance() {
    return reinterpret_cast<const SelectPlayer*>(
               &_SelectPlayer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(SelectPlayer* other);
  friend void swap(SelectPlayer& a, SelectPlayer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectPlayer* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayer>(NULL);
  }

  SelectPlayer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectPlayer& from);
  void MergeFrom(const SelectPlayer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectPlayer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 nGuid = 1;
  void clear_nguid();
  static const int kNGuidFieldNumber = 1;
  ::google::protobuf::int64 nguid() const;
  void set_nguid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:netData.SelectPlayer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 nguid_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsSelectPlayerImpl();
};
// -------------------------------------------------------------------

class SelectPlayerRet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netData.SelectPlayerRet) */ {
 public:
  SelectPlayerRet();
  virtual ~SelectPlayerRet();

  SelectPlayerRet(const SelectPlayerRet& from);

  inline SelectPlayerRet& operator=(const SelectPlayerRet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SelectPlayerRet(SelectPlayerRet&& from) noexcept
    : SelectPlayerRet() {
    *this = ::std::move(from);
  }

  inline SelectPlayerRet& operator=(SelectPlayerRet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SelectPlayerRet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SelectPlayerRet* internal_default_instance() {
    return reinterpret_cast<const SelectPlayerRet*>(
               &_SelectPlayerRet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(SelectPlayerRet* other);
  friend void swap(SelectPlayerRet& a, SelectPlayerRet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SelectPlayerRet* New() const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayerRet>(NULL);
  }

  SelectPlayerRet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL {
    return ::google::protobuf::Arena::Create<SelectPlayerRet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SelectPlayerRet& from);
  void MergeFrom(const SelectPlayerRet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SelectPlayerRet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SelectPlayerRet_EC EC;
  static const EC EC_OTHER =
    SelectPlayerRet_EC_EC_OTHER;
  static const EC EC_SUCC =
    SelectPlayerRet_EC_EC_SUCC;
  static const EC EC_FAIL =
    SelectPlayerRet_EC_EC_FAIL;
  static const EC EC_SERVER =
    SelectPlayerRet_EC_EC_SERVER;
  static const EC EC_AUTH =
    SelectPlayerRet_EC_EC_AUTH;
  static const EC EC_NONE =
    SelectPlayerRet_EC_EC_NONE;
  static const EC EC_LOGINTIME =
    SelectPlayerRet_EC_EC_LOGINTIME;
  static inline bool EC_IsValid(int value) {
    return SelectPlayerRet_EC_IsValid(value);
  }
  static const EC EC_MIN =
    SelectPlayerRet_EC_EC_MIN;
  static const EC EC_MAX =
    SelectPlayerRet_EC_EC_MAX;
  static const int EC_ARRAYSIZE =
    SelectPlayerRet_EC_EC_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  EC_descriptor() {
    return SelectPlayerRet_EC_descriptor();
  }
  static inline const ::std::string& EC_Name(EC value) {
    return SelectPlayerRet_EC_Name(value);
  }
  static inline bool EC_Parse(const ::std::string& name,
      EC* value) {
    return SelectPlayerRet_EC_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string sIP = 6;
  void clear_sip();
  static const int kSIPFieldNumber = 6;
  const ::std::string& sip() const;
  void set_sip(const ::std::string& value);
  #if LANG_CXX11
  void set_sip(::std::string&& value);
  #endif
  void set_sip(const char* value);
  void set_sip(const char* value, size_t size);
  ::std::string* mutable_sip();
  ::std::string* release_sip();
  void set_allocated_sip(::std::string* sip);

  // int32 nCode = 1;
  void clear_ncode();
  static const int kNCodeFieldNumber = 1;
  ::google::protobuf::int32 ncode() const;
  void set_ncode(::google::protobuf::int32 value);

  // int32 nMapID = 2;
  void clear_nmapid();
  static const int kNMapIDFieldNumber = 2;
  ::google::protobuf::int32 nmapid() const;
  void set_nmapid(::google::protobuf::int32 value);

  // int32 nServerID = 3;
  void clear_nserverid();
  static const int kNServerIDFieldNumber = 3;
  ::google::protobuf::int32 nserverid() const;
  void set_nserverid(::google::protobuf::int32 value);

  // int32 nLineID = 4;
  void clear_nlineid();
  static const int kNLineIDFieldNumber = 4;
  ::google::protobuf::int32 nlineid() const;
  void set_nlineid(::google::protobuf::int32 value);

  // int32 nPort = 5;
  void clear_nport();
  static const int kNPortFieldNumber = 5;
  ::google::protobuf::int32 nport() const;
  void set_nport(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:netData.SelectPlayerRet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sip_;
  ::google::protobuf::int32 ncode_;
  ::google::protobuf::int32 nmapid_;
  ::google::protobuf::int32 nserverid_;
  ::google::protobuf::int32 nlineid_;
  ::google::protobuf::int32 nport_;
  mutable int _cached_size_;
  friend struct ::protobuf_Login_2eproto::TableStruct;
  friend void ::protobuf_Login_2eproto::InitDefaultsSelectPlayerRetImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HandShake

// bytes sClientKey = 1;
inline void HandShake::clear_sclientkey() {
  sclientkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShake::sclientkey() const {
  // @@protoc_insertion_point(field_get:netData.HandShake.sClientKey)
  return sclientkey_.GetNoArena();
}
inline void HandShake::set_sclientkey(const ::std::string& value) {
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShake.sClientKey)
}
#if LANG_CXX11
inline void HandShake::set_sclientkey(::std::string&& value) {
  
  sclientkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShake.sClientKey)
}
#endif
inline void HandShake::set_sclientkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShake.sClientKey)
}
inline void HandShake::set_sclientkey(const void* value, size_t size) {
  
  sclientkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShake.sClientKey)
}
inline ::std::string* HandShake::mutable_sclientkey() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShake.sClientKey)
  return sclientkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShake::release_sclientkey() {
  // @@protoc_insertion_point(field_release:netData.HandShake.sClientKey)
  
  return sclientkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShake::set_allocated_sclientkey(::std::string* sclientkey) {
  if (sclientkey != NULL) {
    
  } else {
    
  }
  sclientkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sclientkey);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShake.sClientKey)
}

// -------------------------------------------------------------------

// HandShakeRet

// int32 nCode = 1;
inline void HandShakeRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 HandShakeRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.HandShakeRet.nCode)
  return ncode_;
}
inline void HandShakeRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.HandShakeRet.nCode)
}

// bytes sChallenge = 2;
inline void HandShakeRet::clear_schallenge() {
  schallenge_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShakeRet::schallenge() const {
  // @@protoc_insertion_point(field_get:netData.HandShakeRet.sChallenge)
  return schallenge_.GetNoArena();
}
inline void HandShakeRet::set_schallenge(const ::std::string& value) {
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShakeRet.sChallenge)
}
#if LANG_CXX11
inline void HandShakeRet::set_schallenge(::std::string&& value) {
  
  schallenge_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShakeRet.sChallenge)
}
#endif
inline void HandShakeRet::set_schallenge(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShakeRet.sChallenge)
}
inline void HandShakeRet::set_schallenge(const void* value, size_t size) {
  
  schallenge_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShakeRet.sChallenge)
}
inline ::std::string* HandShakeRet::mutable_schallenge() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShakeRet.sChallenge)
  return schallenge_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShakeRet::release_schallenge() {
  // @@protoc_insertion_point(field_release:netData.HandShakeRet.sChallenge)
  
  return schallenge_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShakeRet::set_allocated_schallenge(::std::string* schallenge) {
  if (schallenge != NULL) {
    
  } else {
    
  }
  schallenge_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), schallenge);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShakeRet.sChallenge)
}

// bytes sServerKey = 3;
inline void HandShakeRet::clear_sserverkey() {
  sserverkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HandShakeRet::sserverkey() const {
  // @@protoc_insertion_point(field_get:netData.HandShakeRet.sServerKey)
  return sserverkey_.GetNoArena();
}
inline void HandShakeRet::set_sserverkey(const ::std::string& value) {
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.HandShakeRet.sServerKey)
}
#if LANG_CXX11
inline void HandShakeRet::set_sserverkey(::std::string&& value) {
  
  sserverkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.HandShakeRet.sServerKey)
}
#endif
inline void HandShakeRet::set_sserverkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.HandShakeRet.sServerKey)
}
inline void HandShakeRet::set_sserverkey(const void* value, size_t size) {
  
  sserverkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.HandShakeRet.sServerKey)
}
inline ::std::string* HandShakeRet::mutable_sserverkey() {
  
  // @@protoc_insertion_point(field_mutable:netData.HandShakeRet.sServerKey)
  return sserverkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HandShakeRet::release_sserverkey() {
  // @@protoc_insertion_point(field_release:netData.HandShakeRet.sServerKey)
  
  return sserverkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HandShakeRet::set_allocated_sserverkey(::std::string* sserverkey) {
  if (sserverkey != NULL) {
    
  } else {
    
  }
  sserverkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sserverkey);
  // @@protoc_insertion_point(field_set_allocated:netData.HandShakeRet.sServerKey)
}

// -------------------------------------------------------------------

// Challenge

// string sHmac = 1;
inline void Challenge::clear_shmac() {
  shmac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Challenge::shmac() const {
  // @@protoc_insertion_point(field_get:netData.Challenge.sHmac)
  return shmac_.GetNoArena();
}
inline void Challenge::set_shmac(const ::std::string& value) {
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Challenge.sHmac)
}
#if LANG_CXX11
inline void Challenge::set_shmac(::std::string&& value) {
  
  shmac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Challenge.sHmac)
}
#endif
inline void Challenge::set_shmac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Challenge.sHmac)
}
inline void Challenge::set_shmac(const char* value, size_t size) {
  
  shmac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Challenge.sHmac)
}
inline ::std::string* Challenge::mutable_shmac() {
  
  // @@protoc_insertion_point(field_mutable:netData.Challenge.sHmac)
  return shmac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Challenge::release_shmac() {
  // @@protoc_insertion_point(field_release:netData.Challenge.sHmac)
  
  return shmac_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Challenge::set_allocated_shmac(::std::string* shmac) {
  if (shmac != NULL) {
    
  } else {
    
  }
  shmac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shmac);
  // @@protoc_insertion_point(field_set_allocated:netData.Challenge.sHmac)
}

// -------------------------------------------------------------------

// ChallengeRet

// int32 nCode = 1;
inline void ChallengeRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 ChallengeRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.ChallengeRet.nCode)
  return ncode_;
}
inline void ChallengeRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.ChallengeRet.nCode)
}

// -------------------------------------------------------------------

// Auth

// string Account = 1;
inline void Auth::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::account() const {
  // @@protoc_insertion_point(field_get:netData.Auth.Account)
  return account_.GetNoArena();
}
inline void Auth::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Auth.Account)
}
#if LANG_CXX11
inline void Auth::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Auth.Account)
}
#endif
inline void Auth::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Auth.Account)
}
inline void Auth::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Auth.Account)
}
inline ::std::string* Auth::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:netData.Auth.Account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_account() {
  // @@protoc_insertion_point(field_release:netData.Auth.Account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:netData.Auth.Account)
}

// bytes Secret = 2;
inline void Auth::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Auth::secret() const {
  // @@protoc_insertion_point(field_get:netData.Auth.Secret)
  return secret_.GetNoArena();
}
inline void Auth::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Auth.Secret)
}
#if LANG_CXX11
inline void Auth::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Auth.Secret)
}
#endif
inline void Auth::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Auth.Secret)
}
inline void Auth::set_secret(const void* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Auth.Secret)
}
inline ::std::string* Auth::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:netData.Auth.Secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Auth::release_secret() {
  // @@protoc_insertion_point(field_release:netData.Auth.Secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Auth::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:netData.Auth.Secret)
}

// -------------------------------------------------------------------

// AuthRet

// int32 nCode = 1;
inline void AuthRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 AuthRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.nCode)
  return ncode_;
}
inline void AuthRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.AuthRet.nCode)
}

// string Account = 2;
inline void AuthRet::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthRet::account() const {
  // @@protoc_insertion_point(field_get:netData.AuthRet.Account)
  return account_.GetNoArena();
}
inline void AuthRet::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.AuthRet.Account)
}
#if LANG_CXX11
inline void AuthRet::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.AuthRet.Account)
}
#endif
inline void AuthRet::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.AuthRet.Account)
}
inline void AuthRet::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.AuthRet.Account)
}
inline ::std::string* AuthRet::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:netData.AuthRet.Account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthRet::release_account() {
  // @@protoc_insertion_point(field_release:netData.AuthRet.Account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthRet::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:netData.AuthRet.Account)
}

// -------------------------------------------------------------------

// Login

// string Account = 1;
inline void Login::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::account() const {
  // @@protoc_insertion_point(field_get:netData.Login.Account)
  return account_.GetNoArena();
}
inline void Login::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Login.Account)
}
#if LANG_CXX11
inline void Login::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Login.Account)
}
#endif
inline void Login::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Login.Account)
}
inline void Login::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Login.Account)
}
inline ::std::string* Login::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:netData.Login.Account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_account() {
  // @@protoc_insertion_point(field_release:netData.Login.Account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:netData.Login.Account)
}

// bytes Secret = 2;
inline void Login::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Login::secret() const {
  // @@protoc_insertion_point(field_get:netData.Login.Secret)
  return secret_.GetNoArena();
}
inline void Login::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.Login.Secret)
}
#if LANG_CXX11
inline void Login::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.Login.Secret)
}
#endif
inline void Login::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.Login.Secret)
}
inline void Login::set_secret(const void* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.Login.Secret)
}
inline ::std::string* Login::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:netData.Login.Secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Login::release_secret() {
  // @@protoc_insertion_point(field_release:netData.Login.Secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Login::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:netData.Login.Secret)
}

// -------------------------------------------------------------------

// LoginRet

// int32 nCode = 1;
inline void LoginRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 LoginRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.LoginRet.nCode)
  return ncode_;
}
inline void LoginRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.LoginRet.nCode)
}

// int32 nTempID = 2;
inline void LoginRet::clear_ntempid() {
  ntempid_ = 0;
}
inline ::google::protobuf::int32 LoginRet::ntempid() const {
  // @@protoc_insertion_point(field_get:netData.LoginRet.nTempID)
  return ntempid_;
}
inline void LoginRet::set_ntempid(::google::protobuf::int32 value) {
  
  ntempid_ = value;
  // @@protoc_insertion_point(field_set:netData.LoginRet.nTempID)
}

// -------------------------------------------------------------------

// PlayerLite

// int64 nGuid = 1;
inline void PlayerLite::clear_nguid() {
  nguid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 PlayerLite::nguid() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.nGuid)
  return nguid_;
}
inline void PlayerLite::set_nguid(::google::protobuf::int64 value) {
  
  nguid_ = value;
  // @@protoc_insertion_point(field_set:netData.PlayerLite.nGuid)
}

// string sName = 2;
inline void PlayerLite::clear_sname() {
  sname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerLite::sname() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.sName)
  return sname_.GetNoArena();
}
inline void PlayerLite::set_sname(const ::std::string& value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.PlayerLite.sName)
}
#if LANG_CXX11
inline void PlayerLite::set_sname(::std::string&& value) {
  
  sname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.PlayerLite.sName)
}
#endif
inline void PlayerLite::set_sname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.PlayerLite.sName)
}
inline void PlayerLite::set_sname(const char* value, size_t size) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.PlayerLite.sName)
}
inline ::std::string* PlayerLite::mutable_sname() {
  
  // @@protoc_insertion_point(field_mutable:netData.PlayerLite.sName)
  return sname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerLite::release_sname() {
  // @@protoc_insertion_point(field_release:netData.PlayerLite.sName)
  
  return sname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerLite::set_allocated_sname(::std::string* sname) {
  if (sname != NULL) {
    
  } else {
    
  }
  sname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sname);
  // @@protoc_insertion_point(field_set_allocated:netData.PlayerLite.sName)
}

// int32 nJob = 3;
inline void PlayerLite::clear_njob() {
  njob_ = 0;
}
inline ::google::protobuf::int32 PlayerLite::njob() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.nJob)
  return njob_;
}
inline void PlayerLite::set_njob(::google::protobuf::int32 value) {
  
  njob_ = value;
  // @@protoc_insertion_point(field_set:netData.PlayerLite.nJob)
}

// int32 nSex = 4;
inline void PlayerLite::clear_nsex() {
  nsex_ = 0;
}
inline ::google::protobuf::int32 PlayerLite::nsex() const {
  // @@protoc_insertion_point(field_get:netData.PlayerLite.nSex)
  return nsex_;
}
inline void PlayerLite::set_nsex(::google::protobuf::int32 value) {
  
  nsex_ = value;
  // @@protoc_insertion_point(field_set:netData.PlayerLite.nSex)
}

// -------------------------------------------------------------------

// PlayerList

// string Account = 1;
inline void PlayerList::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlayerList::account() const {
  // @@protoc_insertion_point(field_get:netData.PlayerList.Account)
  return account_.GetNoArena();
}
inline void PlayerList::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.PlayerList.Account)
}
#if LANG_CXX11
inline void PlayerList::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.PlayerList.Account)
}
#endif
inline void PlayerList::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.PlayerList.Account)
}
inline void PlayerList::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.PlayerList.Account)
}
inline ::std::string* PlayerList::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:netData.PlayerList.Account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlayerList::release_account() {
  // @@protoc_insertion_point(field_release:netData.PlayerList.Account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlayerList::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:netData.PlayerList.Account)
}

// -------------------------------------------------------------------

// PlayerListRet

// repeated .netData.PlayerLite list = 1;
inline int PlayerListRet::list_size() const {
  return list_.size();
}
inline void PlayerListRet::clear_list() {
  list_.Clear();
}
inline ::netData::PlayerLite* PlayerListRet::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:netData.PlayerListRet.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >*
PlayerListRet::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:netData.PlayerListRet.list)
  return &list_;
}
inline const ::netData::PlayerLite& PlayerListRet::list(int index) const {
  // @@protoc_insertion_point(field_get:netData.PlayerListRet.list)
  return list_.Get(index);
}
inline ::netData::PlayerLite* PlayerListRet::add_list() {
  // @@protoc_insertion_point(field_add:netData.PlayerListRet.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::netData::PlayerLite >&
PlayerListRet::list() const {
  // @@protoc_insertion_point(field_list:netData.PlayerListRet.list)
  return list_;
}

// -------------------------------------------------------------------

// CreatePlayer

// string sName = 1;
inline void CreatePlayer::clear_sname() {
  sname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreatePlayer::sname() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.sName)
  return sname_.GetNoArena();
}
inline void CreatePlayer::set_sname(const ::std::string& value) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.sName)
}
#if LANG_CXX11
inline void CreatePlayer::set_sname(::std::string&& value) {
  
  sname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.CreatePlayer.sName)
}
#endif
inline void CreatePlayer::set_sname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.CreatePlayer.sName)
}
inline void CreatePlayer::set_sname(const char* value, size_t size) {
  
  sname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.CreatePlayer.sName)
}
inline ::std::string* CreatePlayer::mutable_sname() {
  
  // @@protoc_insertion_point(field_mutable:netData.CreatePlayer.sName)
  return sname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatePlayer::release_sname() {
  // @@protoc_insertion_point(field_release:netData.CreatePlayer.sName)
  
  return sname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatePlayer::set_allocated_sname(::std::string* sname) {
  if (sname != NULL) {
    
  } else {
    
  }
  sname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sname);
  // @@protoc_insertion_point(field_set_allocated:netData.CreatePlayer.sName)
}

// int32 nJob = 2;
inline void CreatePlayer::clear_njob() {
  njob_ = 0;
}
inline ::google::protobuf::int32 CreatePlayer::njob() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.nJob)
  return njob_;
}
inline void CreatePlayer::set_njob(::google::protobuf::int32 value) {
  
  njob_ = value;
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.nJob)
}

// int32 nSex = 3;
inline void CreatePlayer::clear_nsex() {
  nsex_ = 0;
}
inline ::google::protobuf::int32 CreatePlayer::nsex() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.nSex)
  return nsex_;
}
inline void CreatePlayer::set_nsex(::google::protobuf::int32 value) {
  
  nsex_ = value;
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.nSex)
}

// string Account = 4;
inline void CreatePlayer::clear_account() {
  account_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreatePlayer::account() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayer.Account)
  return account_.GetNoArena();
}
inline void CreatePlayer::set_account(const ::std::string& value) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.CreatePlayer.Account)
}
#if LANG_CXX11
inline void CreatePlayer::set_account(::std::string&& value) {
  
  account_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.CreatePlayer.Account)
}
#endif
inline void CreatePlayer::set_account(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.CreatePlayer.Account)
}
inline void CreatePlayer::set_account(const char* value, size_t size) {
  
  account_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.CreatePlayer.Account)
}
inline ::std::string* CreatePlayer::mutable_account() {
  
  // @@protoc_insertion_point(field_mutable:netData.CreatePlayer.Account)
  return account_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatePlayer::release_account() {
  // @@protoc_insertion_point(field_release:netData.CreatePlayer.Account)
  
  return account_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatePlayer::set_allocated_account(::std::string* account) {
  if (account != NULL) {
    
  } else {
    
  }
  account_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), account);
  // @@protoc_insertion_point(field_set_allocated:netData.CreatePlayer.Account)
}

// -------------------------------------------------------------------

// CreatePlayerRet

// int32 nCode = 1;
inline void CreatePlayerRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 CreatePlayerRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.CreatePlayerRet.nCode)
  return ncode_;
}
inline void CreatePlayerRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.CreatePlayerRet.nCode)
}

// .netData.PlayerLite Info = 2;
inline bool CreatePlayerRet::has_info() const {
  return this != internal_default_instance() && info_ != NULL;
}
inline void CreatePlayerRet::clear_info() {
  if (GetArenaNoVirtual() == NULL && info_ != NULL) {
    delete info_;
  }
  info_ = NULL;
}
inline const ::netData::PlayerLite& CreatePlayerRet::info() const {
  const ::netData::PlayerLite* p = info_;
  // @@protoc_insertion_point(field_get:netData.CreatePlayerRet.Info)
  return p != NULL ? *p : *reinterpret_cast<const ::netData::PlayerLite*>(
      &::netData::_PlayerLite_default_instance_);
}
inline ::netData::PlayerLite* CreatePlayerRet::release_info() {
  // @@protoc_insertion_point(field_release:netData.CreatePlayerRet.Info)
  
  ::netData::PlayerLite* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::netData::PlayerLite* CreatePlayerRet::mutable_info() {
  
  if (info_ == NULL) {
    info_ = ::google::protobuf::Arena::Create< ::netData::PlayerLite >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netData.CreatePlayerRet.Info)
  return info_;
}
inline void CreatePlayerRet::set_allocated_info(::netData::PlayerLite* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:netData.CreatePlayerRet.Info)
}

// -------------------------------------------------------------------

// SelectPlayer

// int64 nGuid = 1;
inline void SelectPlayer::clear_nguid() {
  nguid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 SelectPlayer::nguid() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayer.nGuid)
  return nguid_;
}
inline void SelectPlayer::set_nguid(::google::protobuf::int64 value) {
  
  nguid_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayer.nGuid)
}

// -------------------------------------------------------------------

// SelectPlayerRet

// int32 nCode = 1;
inline void SelectPlayerRet::clear_ncode() {
  ncode_ = 0;
}
inline ::google::protobuf::int32 SelectPlayerRet::ncode() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayerRet.nCode)
  return ncode_;
}
inline void SelectPlayerRet::set_ncode(::google::protobuf::int32 value) {
  
  ncode_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayerRet.nCode)
}

// int32 nMapID = 2;
inline void SelectPlayerRet::clear_nmapid() {
  nmapid_ = 0;
}
inline ::google::protobuf::int32 SelectPlayerRet::nmapid() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayerRet.nMapID)
  return nmapid_;
}
inline void SelectPlayerRet::set_nmapid(::google::protobuf::int32 value) {
  
  nmapid_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayerRet.nMapID)
}

// int32 nServerID = 3;
inline void SelectPlayerRet::clear_nserverid() {
  nserverid_ = 0;
}
inline ::google::protobuf::int32 SelectPlayerRet::nserverid() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayerRet.nServerID)
  return nserverid_;
}
inline void SelectPlayerRet::set_nserverid(::google::protobuf::int32 value) {
  
  nserverid_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayerRet.nServerID)
}

// int32 nLineID = 4;
inline void SelectPlayerRet::clear_nlineid() {
  nlineid_ = 0;
}
inline ::google::protobuf::int32 SelectPlayerRet::nlineid() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayerRet.nLineID)
  return nlineid_;
}
inline void SelectPlayerRet::set_nlineid(::google::protobuf::int32 value) {
  
  nlineid_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayerRet.nLineID)
}

// int32 nPort = 5;
inline void SelectPlayerRet::clear_nport() {
  nport_ = 0;
}
inline ::google::protobuf::int32 SelectPlayerRet::nport() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayerRet.nPort)
  return nport_;
}
inline void SelectPlayerRet::set_nport(::google::protobuf::int32 value) {
  
  nport_ = value;
  // @@protoc_insertion_point(field_set:netData.SelectPlayerRet.nPort)
}

// string sIP = 6;
inline void SelectPlayerRet::clear_sip() {
  sip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SelectPlayerRet::sip() const {
  // @@protoc_insertion_point(field_get:netData.SelectPlayerRet.sIP)
  return sip_.GetNoArena();
}
inline void SelectPlayerRet::set_sip(const ::std::string& value) {
  
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netData.SelectPlayerRet.sIP)
}
#if LANG_CXX11
inline void SelectPlayerRet::set_sip(::std::string&& value) {
  
  sip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netData.SelectPlayerRet.sIP)
}
#endif
inline void SelectPlayerRet::set_sip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netData.SelectPlayerRet.sIP)
}
inline void SelectPlayerRet::set_sip(const char* value, size_t size) {
  
  sip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netData.SelectPlayerRet.sIP)
}
inline ::std::string* SelectPlayerRet::mutable_sip() {
  
  // @@protoc_insertion_point(field_mutable:netData.SelectPlayerRet.sIP)
  return sip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SelectPlayerRet::release_sip() {
  // @@protoc_insertion_point(field_release:netData.SelectPlayerRet.sIP)
  
  return sip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SelectPlayerRet::set_allocated_sip(::std::string* sip) {
  if (sip != NULL) {
    
  } else {
    
  }
  sip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sip);
  // @@protoc_insertion_point(field_set_allocated:netData.SelectPlayerRet.sIP)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace netData

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::netData::HandShakeRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::HandShakeRet_EC>() {
  return ::netData::HandShakeRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::ChallengeRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::ChallengeRet_EC>() {
  return ::netData::ChallengeRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::AuthRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::AuthRet_EC>() {
  return ::netData::AuthRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::LoginRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::LoginRet_EC>() {
  return ::netData::LoginRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::CreatePlayerRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::CreatePlayerRet_EC>() {
  return ::netData::CreatePlayerRet_EC_descriptor();
}
template <> struct is_proto_enum< ::netData::SelectPlayerRet_EC> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netData::SelectPlayerRet_EC>() {
  return ::netData::SelectPlayerRet_EC_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Login_2eproto_INCLUDED
